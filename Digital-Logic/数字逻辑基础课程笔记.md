# 概述
---
## 模拟信号与数字信号
> [!NOTE] 对比
> - 模拟信号(Analog)：连续，时间，数值
> - 数字信号(Digital)：离散且变化，是某个最小量的整数倍

- 模拟电路与数字电路应用接口电路进行信号转换(ADC和DAC)

### 数字电路的特点
1. 采用二进制，易实现，易复制
2. 抗干扰能力强，精度高
3. 可编程性强，集成度高
4. 便于长期存储，使用方便
5. 保密性好

## 数字信号的表示方法

1. 二值逻辑：只有两种对立逻辑状态的逻辑关系，0和1表示逻辑关系而不是数值
2. 逻辑电平：表示逻辑1和逻辑0的电平，如TTL、CMOS等![](Pasted%20image%2020240303232144.png)
3. 波形图(waveform)：用波形图形直观表示0和1
   - 时序图(timing diagram)：将输入信号和输出信号的关系按照时间顺序排列得到的波形图

## 数字电路的基本功能及其应用
- 典型电子信息系统组成框图![](Pasted%20image%2020240303234512.png)

# 数制与编码
---
## 数制
> [!NOTE] 基本要素
> 基数(符号)和位权(规则)
> 1. 基数：数制中每一位数所用到的数码的个数
> 2. 位权：数制中每一固定位置对应的单位值代表的值

| 数制   | 简称               |
| ---- | ---------------- |
| 二进制  | Binary，$B$       |
| 八进制  | Ocral，$O(Q)$     |
| 十进制  | Decimal，$D$      |
| 十六进制 | Hexadecmical，$H$ |

## 二进制符号数的表示方法
### 原码表示
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数为该数绝对值的二进制
> 
> $n$位数字采用原码表示的数据范围$-(2^{n-1}-1)\sim(2^{n-1}-1)$

### 反码表示
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数：正数用原码表示，负数用反码表示
> 
> $n$位数字采用反码表示的数据范围$-(2^{n-1}-1)\sim(2^{n-1}-1)$

### 补码(complement)
> [!NOTE] 定义
> 设数$N$是包含$n$位整数、$m$位小数的二进制数，则$N$的补码表示为$$(N)_{补n}=2^{n}-N$$
> 补码与$N$的大小有关，与整数位数$n$有关，但与小数位数$m$无关

- 求补码的常用方法：
  1. 将原码补足$n$位整数后**整体**求反加1
  2. 将数$N$补足$n$位整数，令从右向左的第一个1及其右边的0不变，其余各位求反

### 补码表示法
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数：正数用原码表示，负数用该数绝对值的补码表示
> 
> $n$位数字采用反码表示的数据范围$-(2^{n-1})\sim(2^{n-1}-1)$

### 求有符号数的相反数
1. 原码表示法：将符号位取反，其余位不变
2. 反码表示法：将整个数值连同符号位一起取反(求反码)
3. 补码表示法：将整个数值连同符号位一起取反加一(求补码)

### 扩展数据的宽度
1. 原码表示法：在符号位与数据位之间填充0
2. 反码和补码表示法：直接进行符号扩展，即正数前面直接补足位的0，负数补1

### 补码表示符号数的加减运算
- 只需要加法器就可以完成加减运算，可以节省硬件节约成本；是符号位直接参与运算，结果仍为补码表示

## 十进制表示的二进制编码——BCD码(Binary Coded Decimal)
- 逻辑相邻：只有一位不同的两组编码
### 自然码(8421BCD)
感觉啥也没变，就是二进制编码

### 5421BCD
- 第一位自反，其他位上下对应![](Pasted%20image%2020240306152705.png)

### 2421BCD
- 直接沿轴自反(4-5之间)

### 余3码
- 前五位=8421码+3，其余各位沿轴自反

### 余3循环码
- 首位与余3码相同，后面位数分别与前一位做异或运算

> [!IMPORTANT] 加法规则
> 两个BCD码相加结果必须还是BCD码；如果相加出的BCD码不合法，应将本位加`0110(10的补码)`，并向高位进位

## 格雷码(gray)
1. 逻辑相邻：相邻两个编码中只有一位不同，其他各位均相同

- 位置相邻的格雷码逻辑相邻
- 最高位自反，其余各位关于中心轴对称![](Pasted%20image%2020240306154415.png)

### 二进制码与格雷码进行转换
- 异或运算：$A\oplus B$
> [!NOTE] 转换方式
> 二进制码转换格雷码：$$G_{n-1}=B_{n-1},~G_{i}=B_{i+1}\oplus B_{i}$$![](Pasted%20image%2020240306154448.png)
> 格雷码转化二进制码：$$B_{n-1}=G_{n-1},~B_{i}=B_{i+1}\oplus G_{i}$$![](Pasted%20image%2020240306154457.png)

# 逻辑代数基础
---
逻辑运算的表示方法：名称、真值表、逻辑表达式、逻辑符号和波形图等

## 逻辑变量和逻辑函数
- 逻辑：事物因果之间遵循的规律，如“与”、“或”、“非”等
- 逻辑变量：逻辑代数中的**二值**变量，取值只有“0”和“1”两个值，代表成对出现的逻辑概念

### 逻辑变量
#### “与”逻辑关系
> [!NOTE] 定义
> 当决定事件的各个条件全部具备之后，事件才会发生，表示为逻辑乘法：$$\mathrm{Y=A\wedge B=A\&B=A\cap B=A\cdot B=AB}$$

- “与”门：![](Pasted%20image%2020240506133317.png)

#### “或”逻辑关系
> [!NOTE] 定义
> 当决定事件的各个条件中有一个或一个以上具备之后，事件就会发生，表示为逻辑加法：$$Y=A\cup B=A\vee B = A|B=A+B$$

- “或”门：![](Pasted%20image%2020240506133731.png)

#### “非”逻辑关系
> [!NOTE] 定义
> 决定事件的条件只有一个，当条件具备时，事件不会发生；条件不存在时，事件发生。表示为逻辑取反：$$Y=\bar A$$

- “非”门：![](Pasted%20image%2020240506133944.png)


- 波形图（以“与”运算为例，$F=A\cdot B$）：![](Pasted%20image%2020240506134142.png)

- 逻辑运算的五种表达方式：**名称**、**真值表**、**逻辑表达式**、**逻辑符号**、**波形图**

### 逻辑函数
> [!NOTE] 定义
> 把“与”、“或”、“非”三种基本逻辑运算结合成逻辑表达式，并将逻辑表达式结果赋予另外一个逻辑变量$$F=A\cdot\bar{B}+\overline{C\cdot D}$$记为$F=(A,B,C,D)$

- 任何形式的逻辑函数，只要各自的真值表相同则彼此相等
- **任何**一个逻辑行为都可以用一个逻辑函数来表述

一个逻辑函数对应了一张真值表，一张真值表对应了一个(若若干个)逻辑函数

## 逻辑代数的基本运算规律

| 名称                | 公式1                                            | 公式2                                            | 类别        |
| ----------------- | ---------------------------------------------- | ---------------------------------------------- | --------- |
| 0-1律              | $A\cdot0=0$                                    | $A+1=1$                                        | 常量和变量间的等式 |
| 自等律               | $A\cdot1=A$                                    | $A+0=A$                                        | 常量和变量间的等式 |
| 自补律               | $A\cdot\bar A=0$                               | $A+\bar A=1$                                   | 常量和变量间的等式 |
| 分配律               | $\mathrm{A\cdot(B+C)=A\cdot B+A\cdot C}$       | $\mathrm{A+B\cdot C=(A+B)(A+C)}$               |           |
| 重叠律               | $A\cdot A=A$                                   | $A+A=A$                                        | 逻辑函数特有    |
| 反演律(德$\cdot$摩根定理) | $\overline{A\cdot B}=\overline{A}+\overline B$ | $\overline{A+B}=\overline{A}\cdot\overline{B}$ | 逻辑函数特有    |

- 逻辑函数中没有指数和系数，没有加法和减法

- 反函数：两个逻辑函数$F$和$G$的输入变量相同，且$F$和$G$对任意一组相同的输入都有相反的函数值，记作$F=\overline G$

### 逻辑代数运算的三个重要规则
1. **代入**规则：任何一个逻辑等式将等式两边出现的同一个逻辑变量都代之以同样的逻辑函数，逻辑等式仍然成立。
2. **反演**规则：对于任意逻辑函数$F$，做以下三种变化后可以得到$F$的反函数$\overline F$：
   1. 把原表达式中的$\cdot$和$+$运算符调换
   2. 把原表达式中的常量0和1调换
   3. 把原表达式中所有原变量换成反变量，反变量换成原变量
   - 需要注意的是，**不能打乱原式的运算顺序**，同时**不属于单变量上的“非”号应保留不变**
3. **对偶**规则：如果两个逻辑函数相等，则它们的对偶函数也相等。求对偶函数的方法如下：
   1. 把原表达式中的$\cdot$和$+$运算符调换
   2. 把原表达式中的常量0和1调换
   3. 原表达式中的原变量和反变量均保持不变
   - **逻辑代数基本运算规律的表格中，公式2是公式1的对偶式**

### 逻辑代数基本定理
#### 合并定理
$$AB+A\overline{B}=A，(A+B)(A+\overline{B})=A$$

#### 吸收定理
$$A+AB=A，A(A+B)=A，A+\overline AB=A+B，A(\overline A+B)=AB$$

#### 添加项定理
$$\begin{aligned}&AB+\overline{A}C+BC=AB+\overline{A}C&(A+B)(\overline{A}+C)(B+C)=(A+B)(\overline{A}+C)\\&AB+\overline{A}C+BCD=AB+\overline{A}C&(A+B)(\overline{A}+C)(B+C+D)=(A+B)(\overline{A}+C)\end{aligned}$$

### 其他
$$\overline{AB+\overline{A}C}=A\overline{B}+\overline{A}~\overline{C}\hspace{0.5cm}\overline{(A+B)(\overline{A}+C)}=(A+\overline{B})(\overline{A}+\overline{C})$$

### 复合运算和符合逻辑门
#### 复合运算
1. “与非”门：$F=\overline{A\cdot B}$![](Pasted%20image%2020240507154415.png)
2. “或非”门：$F=\overline{A+B}$![](Pasted%20image%2020240507154451.png)
3. “与或非”门：$F=\overline{A\cdot B+C\cdot D}$![](Pasted%20image%2020240507154554.png)
4. “异或”门：$F=A\oplus B=A\overline B+\overline AB$![](Pasted%20image%2020240507155237.png)
   1. 多变量“异或”运算取决于变量中取值为1的变量个数：为奇数则异或结果为1，为偶数则异或结果为0
   2. 异或函数中任意一个输入变量取反，运算结果取反
   3. 等式两边的逻辑变量可以互相交换位置而仍然保持等式的成立
5. “同或”门：$F=A\odot B=AB+\overline{A}\overline{B}$![](Pasted%20image%2020240507155657.png)
   1. 多变量“同或”运算取决于变量中取值为0的变量个数：为偶数则异或结果为1，为奇数则异或结果为0
   2. 同或函数中任意一个输入变量取反，运算结果取反
   3. 等式两边的逻辑变量可以互相交换位置而仍然保持等式的成立

#### 逻辑运算符号的完备性
- “与”、“或”、“非”是一组逻辑功能完备的逻辑运算符；“与或”、“或非”、“与或非”运算各自都是功能完备的逻辑运算符

## 逻辑函数的两种标准形式
### 最大项和最小项
- 首先这个部分可以参考一下离散数学的相关章节[离散数学](离散数学.md)(要吐了，好像清git搞没了...)

1. 最小项：$n$个变量的积，其中每个变量都以原变量或反变量的形式出现且仅出现一次
   1. 对于任意一个最小项，只有一组变量使它的值为1
   2. 任意两个不同的最小项乘积(相“与”)恒为0
   3. 全体最小项之和(相“或”)恒为1
2. 最大项：$n$个变量的和，其中每个变量都以原变量或反变量的形式出现且仅出现一次
   1. 对于任意一个最大项，只有一组变量使它的值为0
   2. 任意两个不同的最大项的和(相“或”)恒为1
   3. 全体最大项之积(相“与”)恒为0

#### 最大项与最小项之间的关系
变量数相同，编号相同的最小项和最大项之间存在互补关系，即$$\overline{m_i^n}=M_i^n\text{或}\overline{M_i^n}=m_i^n$$

### 标准表达式1：最小项之和式(标准“与或”式)
> [!NOTE] 定义
> 由若干个最小项相“加”（相“或”）而构成，也叫标准“与或”式

- 任意一个逻辑函数表达式都可以被展开成唯一的最小项之和式，记作$\sum\limits m(1,\cdots,2^n)$,

### 标准表达式2：最大项之积式
> [!NOTE] 定义
> 由若干个最大项相“乘”（相“与”）而构成，也叫标准“或与”式

- 任何一个逻辑函数表达式都可以被展开成唯一的最大项之积式，记作$\prod M(1,\cdots,2^{n})$ 

## 逻辑函数的代数化简法



## 逻辑函数的卡诺图化简法



## 非完全描述逻辑函数



## 逻辑函数的描述


