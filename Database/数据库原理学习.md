# 数据库系统引论
---
## 数据库系统结构
### 数据库系统的三级模式结构
1. Schema(逻辑模式)：应用DDL语言(Database Description Language)，全体数据逻辑结构和特征的描述，构成了数据库的总体框架
2. External Schema(Subschema，外模式)：外模式是用户能看见的局部数据的逻辑结构和特征，是与某一应用具体相关的数据逻辑表示；不同用户有不同的外模式，保障数据安全性；介于模式与应用之间
3. Interal Schema(内模式)：存储模式，一个数据库只能有一个，是整个数据库实际存储的表示；描述数据库存储结构和存取方法
![](Pasted%20image%2020240228090112.png)
### 三级模式结构的二级映像
- 数据库系统的三级模式是对数据的三个抽象级别：**视图级、概念级和物理级**，它使用户能逻辑地抽象地处理数据，而不必关心数据在计算机内部的存储方式，把数据的具体组织交给DBMS管理
- 外模式与模式之间的映像定义局部数据逻辑结构与全局逻辑结构的对应关系，实现了数据的**逻辑独立性**：一个模式对应多个外模式。当**模式结构**改变，则只要修改**外模式与模式**间的对应关系，而不必修改外 模式中的局部逻辑结构，因而相应的应用程序亦可不必修改
- 模式与内模式之间的映像定义全局数据逻辑结构和物理数据存储的对应关系，提供了数据的**物理独立性**：一个模式对应一个内模式。当数据库的**物理存储**结构改变时，仅需要修改**模式与内模式**间的映像关系，而可以使模式保持不变，从而使应用程序保持不变

## 数据库管理系统

### 数据库管理系统的功能

#### 定义功能
1. 模式定义语言(DDL)：定义数据库**全局逻辑**结构，定义记录型和记录的数据项信息，说明数据之间的联系
2. 外模式定义语言：定义用户的**局部逻辑**结构，形式功能与DDL基本相同
3. 内模式定义语言：定义**物理**数据库的结构，包括数据的存储方式、存取方式和检索技术、以及对数据的分区分页

#### 操作功能
数据操纵语言(Data Manipulation Language, DML)实现对数据库的**插入、删除、修改、查询**操作

#### 保护功能
安全性、完整性控制、并发控制和恢复

## 数据库系统的不同视图
数据库的相关人员主要分为四类：**数据库管理员（DBA）、系统分析员、应用程序员和用户**

不同人员涉及数据的抽象级别不同，因而具有不同的数据库视图![](Pasted%20image%2020240228104620.png)
1. 数据库管理员（DBA）：决定数据库中的信息内容和结构、存储结构和存取策略、监控运行安全性以及数据库的改进重组
2. 系统分析员：负责应用系统的需求分析和规范说明，与用户和DBA协商确定硬软件配置，参与数据库的概要设计
3. 数据库设计人员：确定数据，调查用户分析，设计数据库各层模式
4. 应用程序员：设计编写应用系统模块，进行调试安装
5. 用户：偶然、简单和复杂用户

# 数据模型
---
数据模型是数据特征的抽象，用来描述数据的一组概念和定义，包含**数据结构、数据操作和数据的完整性约束**三部分

1. 数据结构：描述数据库组成对象以及对象之间的联系，通常按照数据结构的类型命名数据模型，描述系统静态特性
2. 数据操作：对数据库中各种对象实例允许执行的操作，描述系统动态特性
3. 数据的完整性约束：保证数据的正确、有效和相容

## E-R(Entity-Relationship)概念模型
### 概念定义
1. 实体(Entity)：客观存在并且相互区别的事物，可以是具体对象或抽象概念；具有同类特征的实体集合称为实体集
2. 属性(Attribute)：实体特征称为属性，实体可由若干个属性来刻画；属性分为“类型”和“值”：类型即属性名，属性值的集合构成了一个学生实体
3. 联系(Relationship)：实体之间的联系(不同实体集的联系)，事物内部的联系(实体内部属性之间的联系)；有一一(1: 1)对应、一对多(1: n)和多对多(m: n)等

### E-R图
1. 实体用矩形框表示，属性用椭圆形表示
2. 实体之间的联系用菱形框表示，连线旁标明实体间联系的类型

### 联系
1. 基数比约束：即上文提到的一一(1: 1)对应、一对多(1: n)和多对多(m: n)等
2. 参与约束：一个实体集中的所有实体都参与联系称为完全参与，否则称为部分参与
3. 实体参与度：实体参与联系的最小和最大次数，称为实体的参与度
4. 弱实体：依赖其他实体存在的实体，E-R图中用双框矩形表示，表示全部参与时与菱形用双线连接
5. 子类实体：将一个实体集根据个体的不同特性分为多个子集（有点像Java的子类那种）

### 优势
1. 用户需求不变的情况下，模型稳定
2. 能够方便的转化为具体的DBMS所支持的数据模型

## 层次模型
> [!NOTE] 定义
> 用树型结构表示各类实体以及实体间的联系
> 1. 有且只有一个节点且没有双亲结点(根节点)
> 2. 根节点以外的其他节点有且只有一个双亲结点

### 优势
1. 数据结构简单清晰
2. 查询效率较高
3. 提供了良好的数据完整性支持

### 缺陷
1. 不能直接表示两个以上实体型之间的复杂联系以及实体型之间的多对多联系
2. 对数据插入和删除操作限制过多
3. 查询子女节点必须通过双亲结点

## 网状模型
两个或两个以上的节点都可以有多个双亲结点，有向树变成了有向图

DBTG属于网状数据库系统

### 优点
1. 一个节点有多个双亲的特性更加符合现实世界的关系规则
2. 具有良好的性能，存取效率高

### 缺陷
1. 结构复杂，且随数据量增加复杂程度不断上升，不利于最终用户掌握
2. DDL和DML语言复杂，且访问数据时必须自己选择路径，程序编写有负担

## 关系模型
三要素：关系数据模型、关系操作、关系完整性约束
### 基本概念
基本数据结构被限制为二维表，一个二维表称为一个关系
1. 关系：
   1. 关系(relation)：一个关系可用来表述一个实体集，是一张由行列组成的二维表
   2. 属性(attribute)：每一列为关系的一个属性
   3. 域(domain)：一个属性对应一个值的集合，即域是属性的取值范围，如学号的域为10位数字的集合
   4. 元组(tuple)：关系是元组的集合，一个元组对应实体集的一个个体，可以理解为一条数据
   5. 键(key)：键是由一个或多个属性组成等，能够唯一识别一个元组

2. 关系模式(relation schema)
   1. 关系名(属性1，属性2，$\cdots$，属性n)
   2. **关系数据库模式**是一组关系的集合，这组关系模式对应的关系集合称为关系数据库
   3. 关系模型中基本的数据结构是单一的关系
   4. 关系必须是规范化的，最基本条件即为关系的每一个分量必须是一个不可再分的原子数据项

3. 数据完整性约束
   - 实体完整性、参照完整性、用户自定义完整性

4. 数据操纵
   1. 对数据的查询、插入、删除和修改操作；可以进行多种运算，运算结果又构成新的关系
   2. 关系运算分为关系代数和关系演算

### 关系模型的优势
1. 数据结构简单
2. 一体化数据子语言
3. 数据独立性搞
4. 面向集合的存取方式
5. 坚实的理论基础
6. 有利于开展其他应用


# 关系数据库
---
> [!NOTE] 定义
> 支持关系模型的数据库系统
> 
> 由数据结构、数据操作和完整性约束构成

## 关系模型的基本概念

### 关系的定义
1. 域(domain)：一组具有相同数据类型值的集合，表示属性的取值范围，如$D_{2}=\{male, female\}$，$D_{2}$为域名
2. 笛卡尔积(Cartesian Product)：给定一组集合$\{D_{1},D_{2},\cdots,D_{n}\}$，则集合的笛卡尔积表示为：$$D_1\times D_2\times...\times D_n=\{(d_1,d_2,...,d_n)\mid d_i\in D_i,i=1,2,...,n\}$$表示的是域中所有取值的组合(不能重复)
3. 元组(tuple)：笛卡尔积中每一个元素$(d_{1},d_{2},\cdots,d_{n})$叫做一个$n$元组，简单理解就是任意一种组合
4. 分量(Component)：笛卡尔积元素$(d_{1},d_{2},\cdots,d_{n})$中每一个$d_{i}$叫做一个分量，简单理解就是元组中的一个变量

#### 关系
> [!NOTE] 定义
> $D_1\times D_2\times...\times D_n$的任一个子集称为$\{D_{1},D_{2},\cdots,D_{n}\}$上的一个关系。$N$叫做关系的目或度(degree)

关系中的每一行对应一个元组，通常用$t$表示；每一列对应一个域，关系中的列称为属性，每一列用属性名表示。其中$t[A_{i}]$表示元组$t$在属性$A_{i}$上的值

从笛卡尔积中取出实际有意义的元组构造关系

 严格来说，关系是一种规范化后的二维表中的集合，为了使相应的操作简化对关系加入了限制：例如限定有限数据，为关系每列添加属性以取消有序性等

#### 规范化关系性质
1. 列的同质性(Homogeneous)：每一列中的分量是同一类型的数据，来自同一个域
2. 不同的列可以出自同一个域：不同的属性必须有不同的属性名
3. 行、列的顺序无关
4. 关系中不能出现重复的元组
5. 分量必须取原子值

### 关系模式和关系数据库
- 关系的型称为关系模式(relation schema)，是对关系的描述，一般简记为关系名和属性名的集合
- 关系是值，是元组的集合
- 关系模式的集合称为关系数据库模式，是对数据库中所有数据逻辑结构的描述
- 关系数据库模式中的每个关系模式上的关系的集合称为关系数据库

### 键
> [!NOTE] 定义
> 为区分不同元组，能够唯一标识元组的属性或属性组成为关系的键
> 
> - 其中能够起表示作用的键称为候选键
> - 若有多个候选键，则选一个键作为主键(primary key)
> - 关系键由多个属性组成称为联合键
> - 关系中的所有属性构成关系的键，称为全键

### 完整性约束
1. 实体完整性约束(Entity Integrity Constraint)
   1. 主键的值不能为空或部分为空
   2. 元组键为空将导致元组不可标识，不能表示任何实体，没有意义
2. 参照完整性约束(Reference Integrity Constraint)
   1. 是对关系中作为外键的值的约束

## 关系代数
> [!NOTE] 定义
> 抽象的查询语言，用对关系的运算来表达查询
> 
> 三要素：运算对象、运算结果、运算符

- 运算符分类：
  1. 传统的集合运算：并、差、交、广义笛卡尔积
  2. 专门的关系运算：选择、投影、连接、除，涉及行列运算，是专门为数据库应用而引进的特殊运算

### 传统集合运算
$R$和$S$具有相同的目$n$(即两个关系都具有$n$个属性)，且相应的属性取自同一个域

#### 并运算(Union)
- $R\cup S$仍为$n$目关系，由属于$R$或属于$S$的元组构成，即$$R\cup S=\{t\in  R\vee t\in S\}$$
#### 差运算(Difference)
- $R\cup S$仍为$n$目关系，由属于$R$而不属于$S$的元组构成，即$$R-S=\{t~|~t\in  R\wedge t\notin S\}$$

#### 交运算(Intersection)
- $R\cup S$仍为$n$目关系，由既属于$R$也属于$S$的元组构成，即$$R\cap S=\{t\in  R\wedge t\in S\}$$
- 交运算也可以用差运算来表示，即$R\cap S=R-(R-S)$

#### 笛卡尔积
- $R$中所有元组与$S$中所有元组的拼接，即$$R\times S=\{\widehat{t_\mathrm{r}t_\mathrm{s}}\mid t_\mathrm{r}\in{R}\wedge t_\mathrm{s}\in{S}\}$$![](Pasted%20image%2020240302223122.png)

### 专门关系运算
#### 选择(Selection)
- 从关系中选择满足一定条件的元组子集$$\sigma_{{F}}({R})=\{t\mid t\in{R}\wedge t({F})\}$$其中$F$是限定条件的布尔表达式，由逻辑算符连接比较表达式组成
- 从行的角度进行运算，选择在关系$R$中使$t(F)$为真的所有元组

#### 投影(Projection)
- 模式$R$上的投影运算表示为$$\prod_x({R}){=}\{{t}[{X}]\mid{t}{\in}{R}\}$$其中$\prod$是投影算符，$X$是模式$R$属性的子集，$t[X]$表示$R$中元组在属性集$X$上的值，或为元组$t$在$X$上的投影
- 从列的角度进行运算，从$R$中选出若干属性列组成新的关系

#### (内)连接(Join)
##### 条件连接($\theta$连接)
> [!NOTE] 定义
> 将两个关系中满足$\theta$条件的元组拼接起来形成新元组的集合
>  设属性$A$和$B$分别是关系$R$和$S$上的属性，且定义在同一个域上，$R$和$S$的连接记为：$$R \bowtie_{A\theta B}S~\{\mathrm{t}\mid t=\overset{{\frown}}{{t_r}{t_s}},\mathrm{t_r}\in\mathrm{R}\wedge\mathrm{t_s}\in\mathrm{S}\wedge\mathrm{t_r}[\mathrm{A}]~\mathrm{\theta}~\mathrm{t_s}[\mathrm{B}]\}$$其中，$\bowtie$是连接符，$A\theta B$是连接条件，$\theta$是比较符


- 即从两关系的笛卡尔积中选取两者关系满足连接条件的元组
- 最常用的连接是两个属性值相等的比较，称为等值连接，即$\theta$为$=$

##### 自然连接
> [!NOTE] 定义
> 一种特殊的等值连接，要求两关系中进行比较的分量必须是**相同的属性组**，并且在结果中把重复的属性列去掉
> $$R\bowtie S=\{t~|~t=\overset\frown{t_{r}t_{s}}[\bar{A}],~ t_{r}\in R\wedge t_{s}\in S\wedge t_{r}[A] = t_{s}[A]\}$$

如下图所示，去掉了相同的$R.B$和$S.B$列并合并为$B$列![](Pasted%20image%2020240303182832.png)

#### 除(Division)
> [!NOTE] 定义
> 进行除法运算$\div$，要求两关系有定义在同一域上的属性或属性组；$R\div S$的结果生成一个新关系$R^{\prime}$，$R^{\prime}$的属性是$R$的属性中去掉与$S$具有公共域属性的其他属性
> j
> 设$R(X,Y),~S(Y),~R^{\prime}(X)$，则$R\div S$记为：$$R\div S=R^{\prime}=\{t~|~t\in R^{\prime} \wedge t_{r}\in R \wedge t_{s}\in S\wedge t_{r}[R^{\prime}]=t\wedge t\bowtie S\subseteq R\}$$

如下图，即筛选出$R$中所有$B、C$ 两列全部符合$S$的$A$属性 ![](Pasted%20image%2020240303185815.png)

### 扩充的关系运算
#### 属性重命名
> [!NOTE] 定义
> $$r^{\prime}({R}^{\prime})={\delta}A{\rightarrow}{B}(r)$$其中$A$表示模式$R$中的原属性，$B$表示重命名后的属性，$r$是模式$R$中的一个关系

- 重命名运算可以同时对一组属性进行操作
- 通过重命名运算，可以
  1. 在同一个关系上做自然连接运算
  2. 做同一个关系的笛卡尔积
  3. 将两关系的等值连接方便的表示为自然连接

#### 外连接(Outer join)
> [!NOTE] 定义
> 对自然连接的拓展，连接结果中除了满足连接条件的元组外还包含没有被连接的元组

- 左外连接：连接结果包含了关系$R$(左边关系)中不满足连接条件的元组，这些元组对应关系$S$属性上的值为空值，记为$R\bowtie_{L}S$![](Pasted%20image%2020240303195819.png)
- 右外连接：连接结果包含了关系$S$(右边关系)中不满足连接条件的元组，这些元组对应关系$R$属性上的值为空值，记为$R\bowtie_{R}S$
- 完全外连接：连接结果同时包含了关系$R$(左边关系)和关系$S$(右边关系)中不满足连接条件的元组。即连接结果是左外连接和右外连接的并，记为$R\bowtie_{F}S$

# 关系数据库标准语言SQL
---
## SQL的简介
> [!SUMMARY] 定义
> SQL语言是一种介于关系代数与关系演算之间的语言，是通用、功能极强的关系数据库语言

- SQL的特点：
  1. 综合统一：集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)的功能于一体，能完成数据库生命周期中的全部活动；同时实体间的联系都用关系表示，操作符单一，每种操作只使用一种操作符
  2. 高度非过程化：只需指出“做什么”，无需了解存储路径，提高数据独立性
  3. 面向集合的操作方式：查询、插入、删除和修改操作面向的对象都是集合
  4. 以同一种语法结构提供多种使用方式，不同方式下的语法结构基本一致

## SQL的系统结构
- SQL中的关系模式称为基本表(Table)，基本表的集合构成数据库的模式，对应三级模式结构的模式
- 基本表在物理上与存储文件相对应，所有存储文件的集合为物理数据库
- 外模式（由视图(View)组成）
![](Pasted%20image%2020240317190007.png)
## SQL的数据定义
> [!NOTE] 主要内容
> SQL的数据定义主要包括定义表、定义视图和定义索引，在SQL2中还增加了对数据库模式的定义![](Pasted%20image%2020240317190435.png)

### 模式的定义和删除
- SQL模式由**模式名、权限标识符和模式中元素的描述符**组成
  1. 权限标识符指明拥有该模式的用户或账号
  2. 模式元素包含一个数据库应用的表、视图和索引等
#### 模式定义
- 在定义模式时先给出模式名和权限标识符：`CREATE SCHEMA <模式名> AUTHIRUZATION <用户名>`
- 也可以在模式定义中进行创建表、视图和定义授权等操作
#### 模式删除
- 删除模式语句：`DROP SCHEMA <模式名> [CASCADE | RESTRICT]
  - `CASCADE`(级联式)方式：在删除模式的同时把该模式中的对象全部一起删除
  - `RESTRICT`(限制式)方式：如果该模式已经定义了下属的数据库对象，则拒绝该删除语句的执行

### 基本表的定义、删除与修改
#### 定义基本表
> [!NOTE] 基本语法
> `CREATE TABLE <table name> (<row name> <data type> [列级完整性约束条件] [表级完整性约束条件])`

1. 表名：所定义的基本表名字
2. 列名：组成该表的各个属性(列)
3. 完整性约束条件：
   - 列级完整性约束条件：涉及相应属性列的完整性约束条件
   - 表级完整性约束条件：涉及一个或多个属性列的完整性约束条件
   - 语法为 `constraint <约束名> <约束>`

- 通过 `create table <模式名>.<表名> (...)` 语句格式可以在定义表的同时指定所属的数据库模式名

#### 修改基本表
> [!NOTE] 基本语法
> `ALTER TABLE <table name> [ADD <row name> <data type> [完整性约束]] [DROP <row name> [CASCADE | RESTRICT]] [ALTER <row name> <data type>]`

- `DROP`子句用于删除指定的列名，`RESTRICT`表示必须没有视图和约束引用时才能删除该列
- `ALTER`子句用来修改列的定义，如修改列的数据类型、宽度等

#### 删除基本表
> [!NOTE] 基本语法
> `DROP TABLE <table name> [RESTRICT | CASCADE]`

- 默认约束参数为`RESTRICT`，即不能被其他表参数所引用（如`check`，`foreign key`等）

### 索引的建立与删除
建立索引是加快数据查询速度的有效手段
#### 建立索引
> [!NOTE] 语句格式
> `CREATE [UNIQUE] [CLUSTER] INDEX <index name> ON <table name> (<row name> [<次序>])`

- 索引名可以建立在数据表的一列或多列上，各列名之间用逗号分隔
- `<次序>`指定索引值的排列顺序，其中`ASC`表示升序，`DESC`表示降序，默认参数为`ASC`
- `UNIQUE`表明此索引的每一个索引值只对应唯一的数据记录，对于已经含有重复值的属性列不能建立，同时插入新纪录时DBMS也会自动检测新纪录在该列上是否取了重复值
- `CLUSTER`表示要建立的索引是聚簇索引
  1. 非聚簇索引：数据存储在一个位置，索引存储在另一个位置，索引带有指针指向数据的存储位置
  2. 聚簇索引：对表的物理数据按列进行排序，即索引与数据是一体的，叶节点存储的就是本身的数据
  - 聚簇索引直接确定表中数据的物理顺序，因此一个表中只能有一个聚簇索引；适用于很少对基表进行增删，同时对经常要搜索范围值的列尤其有效
  
#### 删除索引
> [!NOTE] 基本语法
> `DROP INDEX <index name>`

### 索引选择
1. 对某个属性使用索引能极大提高对属性上值的检索效率
2. 但带索引的表占用空间更大，维护索引和对数据进行操作会花费更长时间

- 建立索引：查询操作相比于更新操作更多的属性，经常查询`where`子句中常量进行比较的属性，频繁出现在连接条件中的属性
- 不建立索引：更新操作比较频繁

## SQL的数据操纵
### 数据查询
> [!NOTE] 语句格式
> `SELECT [ALL | DISTINCT] <目标列表达式>`
> 	   `FROM <表名或视图名>`
> 	   `[WHERE <条件表达式>]`
> 	   `[GROUP BY <列名1> [HAVING <条件表达式>]]`
> 	   `[ORDER BY <列名2> [ASC | DESC]]`

- `SELECT`：指定要查询的属性列
- `FROM`：指定查询对象（基本表、视图）
- `WHERE`：指定查询条件
- `GROUP BY`：对查询结果按照指定列经`HAVING`语句筛选后的值进行分组，该属性列值相等的元组为一个组
- `ORDER BY`：对查询结果表按指定列值进行升降序排列

#### 单表查询
- 应用列别名`select <row name> as <bios name>`改变查询结果的列标题
- 使用`DISTINCT`短语消除查询结果中取值重复的行，要注意作用范围是所有目标列，因此不对每一列使用而对整个命令使用

##### WHERE子句常用的查询条件
![](Pasted%20image%2020240318110926.png)
值得注意的是字符串匹配操作中`EACAPE`操作：`WHERE Cname LIKE 'DB\_%i__’ ESCAPE '\'`

##### 使用集函数
如`count, max, min, avg, sum`等，应用类似`SELECT COUNT(DISTINCT Sno) FROM SC`等语句进行计数和求解相关值操作

##### 对查询结果分组
> [!TIPS] 基本语法
> 1. 使用`WHERE`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderhist WHERE productid = 2 GROUP BY productid`
> 
> 2. 使用`HAVING`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderlist GROUP BY productid HAVING SUM(quantity)>=30`

- `WHERE`和`HAVING`语句的区别
  1. 作用对象：`WHERE`作用于基表或视图，选取满足条件的元组；`HAVING`作用于组，选择满足条件的组；可以从与`GROUP BY`的位置关系理解
  2. `WHERE`语句不能使用聚集函数，`HAVING`可以

#### 连接查询
1. 自然连接：等值连接的一种特殊形式，会自动删去重复的行 `SELECT buyer_name, sales.buyer_id, qty FROM buyers, sales WHERE buyers.buyer_id = sales.buyer_id`
2. 自身连接：由于连接的双方完全是同一个表，因此必须起别名加以区分
3. 外连接：相较于内连接的区别在于同时将主体表中不满足连接条件的关系一并输出 `SELECT Student.Sno, Cno FROM Student LEFT JOIN SC ON (Student.Sno = SC.Sno)`，也会输出Sno并不对应的Student表中的关系

#### 嵌套查询
> [!NOTE] 定义
> 将一个查询块嵌套在另一个查询块的`WHERE`子句或`HAVING`短语的条件中的查询称为嵌套查询
> 
> - 子查询不能使用 `ORDER BY` 子句

- 不相关子查询：嵌套查询从里向外进行，即将子查询运算的结果作为父查询的条件
- 相关子查询：取外层查询中表的第一个元组，若内层查询返回结果为`TRUE`则将元组放入结果表

##### 子查询的谓词
1. 带有`IN`谓词的子查询(不相关子查询)：`SELECT <row name> FROM <table name> IN (SELECT <row name> FROM <table name> WHERE ...)`
2. 带有比较运算符的子查询：**子查询一定在比较符之后**，比较特殊的是`<>`等价于`!=`
3. 带有`ANY`或`ALL`谓词的子查询：
   - `ANY`：任意一个值；`ALL`：所有值
   - 跟在比较运算符后面用，类似于 $\exists$ 和 $\forall$
   - 有些时候可以用集函数替代，如 `< ANY` 等价于 `< MAX`，一般用集函数效率更高，能减少比较次数
4. 带有`EXISTS`谓词的子查询：子查询只返回逻辑真假值TRUE或FALSE

#### 集合查询
标准SQL直接支持的只有并(UNION)操作，其余一般支持种类还有交(INTERSECT)、差(EXCEPT/MINUS)等

**属性个数必须一致，对应类型必须一致，与属性名无关，默认去掉重复元组**

##### 并操作
`SELECT * FROM Student WHERE Sdept= 'CS' UNION SELECT * FROM Student WHERE Sage<=19 ORDER BY Sage DESC`

##### 交操作
`(SELECT * FROM Student WHERE Sdept='CS') INTERSECT (SELECT * FROM Student WHERE Sage<=19) ORDER BY Sage DESC`

##### 差操作
`SELECT Sno FROM SC WHERE Sno IN (( SELECT Sno FROM SC WHERE Cno='1') EXCEPT ( SELECT Sno FROM SC WHERE Cno='2'))`

##### 对集合操作结果的排序
只能对**最终查询结果**排序，不能对中间结果排序；任何情况下`ORDER BY`子句都只能出现在最后

> [!IMPORTANT] SELECT语句的一般形式
> `SELECT [ALL|DISTINCT] <目标列表达式> [别名] [，<目标列表达式> [别名]] … FROM <表名或视图名> [别名] [，<表名或视图名> [别名]] … [WHERE<条件表达式>] [GROUP BY<列名1>[，<列名1>] ... [HAVING <条件表达式>]] [ORDER BY<列名2> [ASC|DESC] [，<列名2’> [ASC|DESC] ] … ]；`

### 数据更新
#### 插入数据
1. 插入单个元组：`INSERT INTO <table name> [属性列] VALUES(常量)` 
   1. `INTO`子句：指定插入数据的数据表和属性列，属性列顺序可以与表不一致；不指定属性列表示插入完整元组，指定部分属性列表示其余为空值
   2. `VALUES`子句：提供的值的类型和个数必须与`INTO`子句匹配
2. 插入子查询结果：`INSERT INTO <table name> [属性列] <select 语句>`

#### 修改数据
> [!NOTE] 语句格式
> `UPDATE <表名> SET 列名1=<表达式1>[,列名2=<表达式2>]...[WHERE <条件表达式>]`
> 1. `SET`子句：指定修改方式：要修改的列和修改后的值
> 2. `WHERE`子句：指定要修改的元组，无参数默认修改全部元组

#### 删除数据
`DELETE FROM <表名> [WHERE<条件>]`

## SQL中的视图
> [!NOTE] 定义
> 视图提供了一种观察数据的逻辑窗口，对视图的操作也是对基表进行相对应的操作。

### 视图的定义
#### 建立视图
> [!NOTE] 基本语句
> `CREATE VIEW <视图名> [列名] AS <子查询> [with check option]`
> - 其中`SELECT`语句表示子查询，但一般不包括`ORDER BY`子句和`DIStiNCT`短语
> - `WITH CHECK OPTION`：在通过视图执行增删改查操作时，不得破坏视图定义的谓词条件(即子查询的条件表达式)

- 组成视图的属性列名全部省略或全部指定
  - 省略: 由子查询中SELECT目标列中的诸字段组成 
  - 明确指定视图的所有列名: 
    1. 某个目标列是集函数或列表达式 
    2. 目标列为$*$
    3. 多表连接时选出了几个同名列作为视图的字段
	4. 需要在视图中为某个列启用新的更合适的名字

- 需要注意的是带表达式的视图必须明确定义组成视图的各个属性列名，如 `CREATE VIEW D-Sage(Sdept, Avgage) AS SELECT Sdept, AVG(Sage) FROM Student GROUP BY Sdept`

- 应尽可能避免以 `SELECT *` 方式创建的视图，因为当修改基表的结构时视图与基表的映像关系会被破坏，不宜扩充

#### 删除视图
`DROP VIEW <视图名>`

删除基表时，由该基表导出的所有视图定义都必须显式删除

### 视图上的的操作

- DBMS实现视图查询的方法
  1. 实体化视图(View Materialization)：执行有效性检查，进行视图定义将视图实体化(临时表)，并在查询工作中转化为查询临时表
  2. 视图消解法(View Resolution)：执行有效性检查，把视图定义中的子查询与用户的查询结合起来转化为对基本表的查询
     - 即会将操作结合基表的限制条件转化对为最底层表的查询操作

#### 查询
- 原查询：`SELECT * FROM Sage_23 WHERE Sdept='计算机'`
- 转换后的查询：`SELECT * FROM Student WHERE Sdept='计算机' AND Sage < 23`

#### 更新(即增删改)
插入`INSERT`，删除`DELETE`，更新(已有关系元组的信息)`UPDATE`

#### 视图的优点
1. 提供了数据的逻辑独立性：通过建立一个视图，使用户的外模式不变；从而当数据库逻辑结构发生改变时，对原表的查询程序不需要进行修改
2. 简化用户视图：如基于多张表的连接形成的视图，复杂嵌套的视图等
3. 使用户以不同角度看待相同的数：适应数据库共享的需要
4. 提供了安全保护功能：使不同用户只能看到他有权看到的数据

## SQL的数据控制
### 授权
> [!NOTE] 语句格式
> `GRANT {<权限1>, <权限2>, …} ON [owner.] <表名或视图名> TO {<用户名1>,<用户名2>, … | PUBLIC} [WITH GRANT OPTION]`
> - `<权限>` 指 `SELECT, DELETE` 等操作
> - 当有 `WITH GRANT OPTION` 时，被授权的用户还可以把获得的权限再授权给其他用户
> - 可以同时授权多个用户，如果用`public`则表示将权限授予所有数据库用户

### 权限回收
> [!NOTE] 语句格式
> `REVOKE {<权限1>, <权限2>, …} ON [Owner.] <表名或视图名> FROM {<用户名1>,<用户名2>, … | PUBLIC} [RESTRICT|CASCADE]`
> - `CASCADE`权限表示回收带有级联操作，即同时回收拥有 `WITH GRANT OPTION` 权限的用户授予出的用户权限
> - `RESTRICT`权限表示只有当用户没有将拥有的权限转授给他人时才能回收权限，否则系统将拒绝执行

## 嵌入式SQL


# 关系查询处理与查询优化
---
## 关系数据库系统的查询处理
### 查询处理过程
> [!NOTE] 查询过程
> 对查询语句进行扫描、词法分析和语法分析$\rightarrow$进行用户权限和完整性检查$\rightarrow$建立查询的内部表示(语法树)$\rightarrow$选择高效的查询处理策略用关系代数优化，进行代数优化$\rightarrow$生成查询计划

1. 解释方式：DBMS不保留可执行代码，每次重新执行查询语句，事务完成后返回结果。灵活应变性强，但效率较低，主要适用于不重复使用的偶然查询
2. 编译方式：先进行编译处理生成可执行代码，运行时直接执行可执行代码。执行效率高，系统开销小

### 执行查询操作的基本算法
#### 选择操作
1. 顺序扫描：按照元组物理顺序扫描每个元组，适用于被选中的元组占有较大比例或总元组数较小的关系。搜索代价为$B_{R}$
2. 二分查找法：物理文件按照选择字段有序排列。对于完全有序数据的搜索代价为$\lceil log_{2}B_{R}\rceil$
3. 索引(散列)扫描法：通过索引找到满足条件的元组指针，再通过指针检索满足查询条件的元组。适用于选择条件属性上有索引(B+,Hash等)
4. 复合选择(逻辑合取AND)：使用组合索引，使用单独索引(先找满足一个条件的元组指针，再判断这些元组是否满足另一个条件)，使用多个索引(分别检索满足两个条件的元组指针，然后合取交集)

#### 连接操作
1. 嵌套循环法：两组数据分别为内外循环直接连接，一般选用较少块的文件作为外循环的连接代价较小，**不需要特别存取路径或特殊处理**
2. 索引嵌套循环法：如果两个连接属性中的一个属性存在索引，可以适用索引扫描代替顺序扫描
3. 排序合并法：先按照搜索属性进行排序，依次搜索另一个表中具有相同属性的元组并连接，扫描到第一个不相同的元组就继续搜索源表的下一个元组。两个表都只需要搜索一次，尤其对于已经排序好的表大大减少连接时间
4. 散列连接法(Hash Join)：把连接属性作为Hash码，用同一个hash函数将两个表的元素散列到同一个hash文件中
   1. 划分阶段(partitioning phase)：对包含元素较少的表进行处理，将元组按hash函数分散到哈希表的桶中
   2. 连接阶段(join phase)：将另一个表经过hash函数散列到适当的桶中，并与与之匹配的元组连接起来

#### 投影操作
主要通过消除重复元组(如果投影属性列是主键则不用)，可以通过排序消除或者散列法(分到合适的桶，检查桶内是否有重复的元组)

#### 集合运算
并差交运算通常使用类似排序合并法，笛卡尔积运算通常使用嵌套循环法

## 关系数据库系统的查询优化
> [!TIPS] 由DBMS进行优化的好处
> 1. 优化器可以从数据字典中获取一系列用户无法获取的统计信息
> 2. 如果数据库物理信息发生改变，系统可以自动对查询重新优化选择合适的执行计划
> 3. 优化器能考虑更多种执行计划，并且包含了很多复杂优化技术

### 查询优化技术
1. 代数优化：通过改变代数表达式中操作的次序和组合，使查询执行更高效，不涉及底层存取路径
2. 存取路径优化：通过考虑数据的物理组织和访问路径，选取各种操作合适的存取路径
3. 代价估算优化：对于多个可选的查询策略，通过估算执行策略的代价，从中选择代价最小的作为执行策略

## 代数优化
- 策略：通过对关系代数表达式的等价变换提高查询效率

### 关系代数表达式的等价变换规则
1. 连接、笛卡尔积交换律：选择小关系作为外关系进行连接，提高执行效率
2. 连接、笛卡尔积的结合律
3. 投影的串接定律：对同一关系代数表达式的多个投影可以转换成其中最小的属性集的投影$$\prod_{A1,A2,...,An}\left(\prod_{B1,B2,...,Bm}\left(E\right)\right)\equiv\prod_{A1,A2,...,An}\left(E\right)$$
4. 选择的串接定律：选择条件可以合并，这样一次就可以检查全部条件$$\sigma_{F_1}(\sigma_{F_2}(\mathbb{E})){=}\sigma_{F_1\wedge F_2}(\mathbb{E})$$
5. 选择与投影的交换律：投影操作后的选择操作可以转化为选择操作后的投影操作
6. 选择与笛卡尔积的交换律：
   1. 若$F$中涉及的都是$E_{1}$中的属性，则有$\sigma(E_{1}\times E_{2})\equiv\sigma_{F}(E_{1})\times E_{2}$
   2. 设$F=F_{1}\wedge F_{2}$，且$F_{1},F_{2}$分别只涉及$E_{1},E_{2}$上的属性，则有$\sigma(E_{1}\times E_{2})\equiv\sigma_{F_{1}}(E_{1})\times\sigma_{F_{2}}(E_{2})$
7. 投影与笛卡尔积的分配律

### 代数优化策略
1. 在关系代数表达式中**尽早**执行选择操作，目的是**减小中间关系**（最重要、最基本）
2. 投影运算和选择运算同时进行，目的是**避免重复扫描关系**
3. 将投影运算与其前后的双目运算结合，目的是**减少扫描关系的遍数**
4. 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，执行前对关系进行适当预处理（按连接属性排序，建立索引等）
5. 找出公共子表达式

### 代数优化算法

## 基于存储路径的优化
物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划

### 选择操作的启发式规则
1. 小关系使用全表顺序扫描，即使选择列上有索引
2. 对于大关系，若选择条件是“主键=值”的查询，说明查询结果最多为一个元组，可以选择主键索引；若选择条件是“非主属性=值”的查询，需要估计查询结果的元组数目，比例较小可以使用索引扫描，否则还是使用全表顺序扫描
3. 用`AND`连接的合取选择条件，优先采用组合索引扫描；若某些属性上有一般索引可以使用索引扫描，否则全表顺序扫描
4. 用`OR`连接的析取选择条件，一般使用全表顺序扫描

### 连接操作的启发式规则
1. 两表都已经按照连接属性排序：**排序-合并**方法
2. 一个表中在连接属性上有索引：**索引连接**方法
3. 上述方法都不适用且有一个表较小：**Hash join**方法
4. **嵌套循环**方法，选择较小的表作为外表

## 基于代价估算的优化
### 统计信息
1. 对每个基本表：
   1. 表的元组总数(N)
   2. 元组长度(l)
   3. 占用的块数(B)
   4. 占用的溢出块数(BO)
2. 对基表的每个列
   1. 该列不同值的个数(m)
   2. 选择率(f)：具有该值的元组数 / N
   3. 该列最大最小值
   4. 该列是否建立索引，索引类型
3. 对索引
   1. 索引层数(L)
   2. 不同索引值的个数
   3. 索引的选择基数S：有S个元组具有某个索引值
   4. 索引的叶节点数(Y)

- [ ] 具体的代价优化计算我只能说看不懂....再说吧

## 小结
- 代数优化基数指关系代数表达式的优化，即按照一定规则改变代数表达式中操作的次序和组合，使查询执行更高效
- 基于存取路径的优化是指存取路径和底层操作算法的选择优化
- 代价估算优化是对多个查询策略的优化选择
- 启发式规则优化是定性的选择，适合解释执行的系统
- 大型集中式关系数据库，查询优化的重点是使**访问存储器的代价**最小化

- 比较复杂的查询，尤其是涉及连接和嵌套的查询，不应把优化的任务全部放在RDBMS上，应找出RDBMS的优化规律以写出适合自动优化的SQL语句

# 数据库的安全性
---
数据库安全性指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏

## 计算机安全性概述
三类计算机系统安全性问题：技术安全（硬件、软件保护）、管理安全和政策法律

TCSEC/TDI标准的基本内容：安全策略、责任、保证和文档

## 数据库安全性概述
数据库的安全性不是独立的：数据库系统层、操作系统层、网络层

- 数据库系统的安全技术主要包括以下几类：
  1. 访问控制技术：防止未授权的用户访问系统本身，主要通过账号密码由DBMS控制登录过程实现
  2. 存取控制技术：保证用户只能访问其权限范围内的数据
  3. 数据加密技术：保护敏感数据的传输存储
  4. 数据库审计：记录数据库访问情况

## 用户标识与鉴别
基本方法：通过用户标识来获得授权，最常用的方法是用户名(`user name`)，用户账号(`user account`)以及口令(`password`)来标识用户身份

## 存取控制
- DBMS安全子系统：
  1. 定义用户权限：定义用户存取权限，保证用户只能访问其有权限存取的数据
  2. 合法权限检查：对合法用户根据其权限定义对他的操作进行控制，确保其只进行合法操作

当前DBMS都支持C2级的自主存取控制(DAC)，有些DBMS还支持B1级的强制存取控制(MAC)
1. 自主存取控制：同一用户对不同数据对象有不同的存取权限，不同用户对同一对象有不同权限，用户还可将其拥有的权限转授给其他用户
2. 强制存取控制：严格，每一个数据对象被标以一定的密级，每一个用户被授予某一个级别的许可证

### 自主存取控制
- 主体(Subject)是一个提出请求的实体，可以是DBMS管理的实际用户，或其他任何代表用户行为的进程、作业和程序
- 客体(Object)是接受其他实体访问的被动实体，受主题操纵，可以是文件、记录和视图等

- 控制策略是主体对客体的操作行为集和约束条件集，即主体对客体的访问规则集
- 通过SQL的`GRANT`语句和`REVOKE`语句实现
![](Pasted%20image%2020240503161919.png)
- 授权粒度：指可以定义的数据对象的范围，是衡量授权机制是否灵活的一个重要指标；授权定义中数据对象的粒度越细，即可以定义的数据对象的范围越小，授权子系统就越灵活，但系统定义与权限检查的开销将增加

#### 自主存取控制的实现
![](Pasted%20image%2020240503164142.png)

#### 数据库角色
- 在用户数量比较大的情况下，便于权限管理，相当于为一组具有相同权限的用户创建一个角色

1. 创建角色：`CREATE ROLE <角色名>`
2. 给角色授权：`GRANT <权限> [, <权限>] ON <对象类型> 对象名 TO <角色> [, <角色>]`
3. 将一个角色授予其他角色或用户：`GRANT <角色> TO <角色1>[, <用户>]`
4. 角色权限的收回：`REVOKE <权限> [, <权限>] ON <对象类型> 对象名 FROM <角色> [, <角色>]`

#### 权限的传播
- 自主存取控制优点：能够通过授权机制有效地控制其他用户对敏感数据的存取
- 缺点：存取权限自主，权限可以传播，接受授权的用户可以非法传播数据造成数据“无意泄露”；可以通过强制存取控制策略解决

### 强制存取控制
强制存取控制(MAC)是为了保证更高安全性，所采取的强制存取检查手段，不是用户能直接感知或控制的

- 主体：DBMS管理的实际用户，代表用户的各进程
- 客体：受主体操纵的系统被动实体，如文件、基表、索引和视图等
- 典型的安全分类级别为：TS(Top Secret)，S(Secret)，C(Confidential)和Public

- 控制规则：仅当主体许可证级别**大于等于**客体的密级时，主体才能读取相应的客体；仅当主体的许可证级别**小于等于**客体的密级时，主体才能写相应的客体

## 视图机制
进行存取权限控制时可以为不同用户定义不同的视图，把数据对象限制在一定范围内，把要保密的数据对无权限的用户隐藏起来，更主动地对数据提供一定程度的保护

## 数据加密
基本思想：根据一定算法将原始数据变换为不可直接识别的形式；比较费时，占用空间

## 数据库审计
1. 审计日志(Audit Log)：将用户对数据库的所有操作记录在上面
2. DBA利用审计日志：找出非法存取数据的用户、时间和内容
3. C2安全级别以上的DBMS必须具有

- 用户级审计：针对自己创建的数据库表或视图进行审计，记录对这些表或视图的一切访问要求和SQL操作
- 系统级审计：DBA设置，监测成功或失败的登陆要求，监测`GRANT`和`REVOKE`操作以及其他数据库级权限下的操作

`AUDIT` 语句：设置审计功能；例如对修改表结构或修改表数据的操作进行审计：`AUDIT ALTER, UPDATA ON <表名>`

`NOAUDIT`语句：取消审计

## 统计数据库的安全性
1. 允许查询聚集类型的信息（如合计、平均等信息），但不允许查询单个记录信息
2. 主要的安全性问题存在于可能通过合法的聚集类型信息查询中推导出不合法的单个信息

受限于其安全性问题，统计数据库有如下规则：
1. 任何查询要涉及$N$个($N$足够大)以上的记录
2. 任意两个查询的相交数据项不能超过$M$个
3. 任意用户的查询次数不能超过$1+\frac{N-2}{M}$

## SQL Server的安全控制
### SQL Server的安全体系结构
- SQL Server的安全体系结构分为4个等级：客户机操作系统安全性，SQL Server的登陆安全性，数据库使用安全性，数据库对象使用安全性
- SQL Server对用户访问进行两阶段验证：验证阶段和许可确认阶段

### 登陆管理
例如为用户创建一个SQL Server登录并指定密码：`EXEC ap_addlogin 'user name', 'password', 'Normal database'`

### 数据库用户管理
1. 登陆账户(login name)：不能对数据库进行操作，只是连接到SQL Server上
2. 使用数据库的账户(user name)：登陆账户想要访问数据库必须要与使用数据库的账户相关联

### 权限管理
1. 对象权限：针对数据库中的表、视图和存储过程，决定对这些对象能执行哪些操作
2. 语句权限：用户是否具有权限执行某条语句
3. 系统权限（隐含权限）：SQL Server预定义的系统角色成员执行的活动

### 角色管理
#### 服务器角色
根据管理任务以及任务相对重要性等级，把具有SQL Server管理职能的用户划分为不同的用户组![](Pasted%20image%2020240503210118.png)

#### 数据库角色
为某一用户或一组用户授予不同级别的管理或访问数据库或数据库对象的权限![](Pasted%20image%2020240503210600.png)

# 数据库的完整性
---
数据的正确性和相容性，防止数据库中存在不正确的数据
## 数据库的完整性概述
防止数据库中存在不符合语义的数据和不正确的数据，以保证数据库中数据的质量

- 因此，为维护数据库完整性，DBMS必须：
  1. 提供定义完整性约束条件的机制
  2. 提供完整性检查的方法
  3. 违约处理

### 完整性约束条件
- 加载数据上的语义约束条件称为数据库完整性约束条件，一般是对数据库中数据本身的某种语义限制、数据间的逻辑约束和数据变化时所遵循的规则等

1. 列级约束
   1. 对数据类型的约束：如数据类型、长度、精度等
   2. 对数据格式的约束
   3. 对取值域的约束和对空值的约束
2. 元组约束：定义元组中各个属性之间的约束关系，例如订货关系中发货日期不能小于订货日期
3. 关系约束：一个关系的各个元组之间存在的各种联系或约束，如实体完整性、参照完整性约束等

### 实现数据完整性的方法
1. 默认值：如果插入行中没有指定列的值，那么默认值指定列中所使用的值
2. 约束：自动强制数据完整性，优于触发器、规则和默认值
3. 规则：向后兼容，执行与`CHECK`相同的功能；以单独对象创建，绑定到列上
4. 触发器：数据库系统中强制业务规则和数据完整性的主要机制

- 声明式数据完整性：作为对象定义的一部分定义数据必须达到的标准，DBMS自动强制，通过使用约束、默认和规则实现
- 过程式数据完整性：脚本强制完整性，使用触发器和存储过程实现，在客户端用编程语言和工具实现

## 实体完整性
**主键值不能取空值，主键值唯一**，通过对主键值约束实现实体完整性

### 实体完整性的定义
- 在 `CREATE TABLE` 中用 `PRIMARY KEY` 定义，可以作为表定义的一部分在创建表时定义，也可以在表创建之后再添加
- 对于单属性构成的主键可以定义为列级或表级约束条件，但对于多个属性构成的主键只能定义为表级约束条件
- 列级：`<表名> <数据类型> PRIMIRY KEY`；表级：`PRIMARY KEY (<表名1> [, <表名2>])`
- 为了实施实体完整性，系统将在主键属性上自动创建唯一索引来强制唯一性约束

### 实体完整性检查和违约处理
1. 使用全表扫描法检查记录中主键值是否唯一
2. 使用索引判断主键是否存在

- 定义表主键后，每当对表插入一条记录或对主键进行更新操作时，DBMS自动进行实体完整性检查：如果主键不唯一或主键有空的字段值则拒绝操作

## 参照完整性
用 `FOREIGN KEY` 短语定义哪些列为外键，用 `REFERENCES` 短语指明外键参照哪些表的主键

### 参照完整性检查和违约处理
1. 外键空值问题：若外键是主键的组成部分则不允许为空，否则可以根据具体语义决定外键值是否可以为空
2. 在参照关系中插入元组的问题：若插入的元组中有被参照表中不存在的属性，则系统会拒绝；可以采用级联`CASCADE`插入，即先向被参照关系插入主键值等于参照关系插入元组外键值的相应元组，再向参照关系插入该元组
3. 在被参照关系中删除元组元组的问题
   1. 级联删除(CASCADE)：将参照关系中所有外键值与被参照关系中要删除元组之间值相同的元组
   2. 受限删除(RESTRICT)：如果参照和被参照关系中被删除的元组存在相同主键和外键，系统拒绝删除
   3. 置空值删除(SET-NULL)：删除被参照关系元组，并将参照关系中相应元组外键置为空值
   `alter table <参照表名> add constraint <约束名> foreign key(<列名>) references <被参照表名>(被参照列名) on delete {cascade | restrict | set-null}`

## 用户定义的完整性
针对某一具体应用的数据必须满足的语义要求

### 用户定义完整性定义
1. 属性上的约束条件定义：唯一`UNIQUE`、非空`NOT NULL`、`CHECK`约束、默认值`DEFAULT`等
2. 元组上的约束条件定义：用`CHECK`短语定义不同属性之间的相互约束条件

### 完整性约束命名子句
- 定义 `CONSTRAINT` 约束：`CONSTRAINT <完整性约束条件名> [主键短语 | 外键短语 | CHECK短语]`![](Pasted%20image%2020240503235929.png)

- 修改表中的完整性限制：使用 `ALTER TABLE` 语句修改表中的完整性限制，可以先使用 `DROP CONSTRAINT <约束名>`删除原来的约束条件，再使用 `ADD CONSTRAINT <完整性约束条件名> [主键短语 | 外键短语 | CHECK短语]` 添加新的约束条件

## SQL Server中数据库完整性的实现
- 设计表时需确定以下内容：
  1. 表中需要的列以及每一列的类型（必要时还需要考虑长度）
  2. 列是否可以为空
  3. 是否需要在列上使用约束、默认值和规则
  4. 需要使用什么样的索引
  5. 哪些列作为主键

### 决定使用何种约束
![](Pasted%20image%2020240504003805.png)

### 外键约束
例：使用 `FOREIGN KEY` 约束，确保Orders表中的客户标识与Customers表中的有效客户标识相关联
`alter table dbo.Orders add constraint FK_Orders_Customers foreign key(CustomerID) references dbo.Customers(CustomerID)`

- 主键和外键的约束类型必须严格匹配
- 外键约束不能自动创建索引，需要手动构建
- 一个表中最多可以有31个外键约束
- 临时表中不能使用外键约束

### UNIQUE约束
`alter table dbo.Suppliers add constraint U_CompanyName UNIQUE NONCLUSTERED (CompanyName)`

1. UNIQUE约束的字段允许为空值
2. 可以把唯一性约束定义在多个字段上
3. 唯一性约束用于强制在指定字段上创建一个唯一性索引，默认创建的索引类型为非聚簇索引

## 触发器
> [!NOTE] 定义
> 触发器是用户定义在关系数据表上的一类由事件驱动的特殊过程，用编程方法实现复杂业务规则
> 
> 触发器比约束更加灵活，具有更精细和更强大的数据控制能力

- 作为一种特殊类型的存储过程，在对表或视图发出 `UPDATE, INSERT, DELETE` 语句时自动执行

1. 实现更加复杂业务规则
2. 比 `CHECK` 约束更复杂的数据完整性
3. 比较数据修改前后的状态
4. 维护非规范化数据

### 定义触发器
- SQL使用 `CREATE TRIGGER` 命令创建触发器，一般格式为：`create trigger <触发器名> {before | after} <触发事件> on <表名> for each {row | statement} [<触发条件>] <触发动作体>`
  1. 创建者：表的拥有者
  2. 触发器名，表名：触发器的目标表
  3. 触发事件：`UPDATE, INSERT, DELETE`
  4. 触发时间：`before | after`，先/后执行出发时间操作
  5. 触发器类型：行级触发器(`for each row`，对每一个修改元组都触发)和语句级触发器(`for each statement`，只在SQL语句执行时进行触发条件检查)

- Inserted表：存放insert或update语句执行过程中，插入到触发表中的新数据行的副本
- Deleted表：存放delete或update语句执行过程中，从触发表中删除的旧数据行的副本

- 触发器执行速度快，因为 inserted 表和 deleted 表都在缓存中；但系统开销更大，优先考虑使用约束

## 决定使用什么强制方法
![](Pasted%20image%2020240504013007.png)

# 数据库恢复技术
---
数据库回复技术用于事务终止后的处理和系统故障恢复处理，确保系统发生故障后能够恢复数据库
## 事务的基本概念和特征
> [!NOTE] 定义
> 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位
> 
> 事务时一系列的数据库操作，是恢复和并发控制的基本单位

- 事务处理技术主要包括**数据库恢复技术**和**并发控制技术**

### 事务的基本概念
1. 定义事务
   - 显式方式：`begin transaction <SQL语句> ... {commit | rollback}`
   - 隐式方式：按默认规定自动划分事务
2. COMMIT提交事务：事务正常结束，提交事务的所有操作(读+更新)，事务中所有对数据库的更新永久生效
3. ROLLBACK回滚事务：事务运行过程中发生故障，恢复到事务开始时的状态

### 事务特征(ACID)
1. 原子性(Atomicity)：数据库逻辑工作单位(最小工作单位)
2. 一致性(Consistency)：数据库中只包含成功事务提交的结果，事务执行结果一定是从一个一致性状态转变到另一个一致性状态
3. 隔离性(Isolation)：一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能相互干扰
4. 持续性(Surability)：事务一旦提交，对数据库中数据的改变就应该是永久性(Permanence)的

### 事务状态
- 事务应该处在下列状态之一：
  1. 活动状态(active)：初始状态，事务执行时的状态
  2. 部分提交状态(partially commited)：事务最后一条语句被执行完毕后进入部分提交状态，结果数据还驻留在内存中
  3. 失败状态(failed)：事务没有成功完成，需要回滚(Rollback)撤销事务已经做出的任何数据更改
  4. 终止状态(aborted)：事务回滚并已经恢复到事务执行前的状态
  5. 提交状态(commited)：将事务更改完全写入磁盘并写入一条事务日志信息，事务成功完成

## 数据库恢复的必要性
### 系统故障
造成系统停止运转的任何事件，使得系统需要重启。常见原因由操作系统或DBMS代码错误，操作员操作事务，特定类型硬件错误，突然停电等

- 修复系统故障
  1. 清除尚未完成事务对数据库修改：重启时强行撤销(UNDO)所有未完成事务
  2. 将缓冲区中已完成事务结果写入数据库：重启时重做(REDO)所有已提交事务

### 事物内部故障
事务运行过程中未运行至正常终止点就夭折了，在此特指非预期故障

通过撤销事务(UNDO)来进行恢复

### 介质故障
硬件故障使存储在外存中的数据部分丢失或全部丢失，破坏性很大

### 恢复的实现技术
基本原理为**冗余**

通过数据转储(backup)和登记日志文件(logging)两种方式来建立冗余数据

## 数据转储与恢复
DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程

### 静态转储
- 在系统中无运行事务时进行转储，转储开始时数据库处于一致性状态
- 实现简单，但是降低了数据库的可用性(转储必须等用户事务结束，且新事务开始必须等转储操作结束)

### 动态转储
- 转储操作与用户事务并发进行，转储期间允许对数据库进行存取或修改
- 不能保证副本中的数据正确有效，需要配合日志进行恢复

### 海量转储与增量转储
- 海量转储：每次转储全部数据库
- 增量转储：只转储上次更新过的数据

## 基于日志的数据库恢复
### 数据库系统日志文件
记录有关事务的数据库操作信息

- 格式分为以记录为单位和以数据块为单位的日志文件，内容包括事务标识、操作类型、操作对象和更新前后的数据值

- **事务故障恢复**和**系统故障恢复**必须使用日志文件
- 动态转储方式必须建立日志文件，后备副本和日志文件综合才能将数据库恢复到一致性状态
- 日志与静态转储后备副本配合进行**介质故障恢复**

- 登记日志文件必须遵循两条规则：
  1. 登记次序严格按照并行事务执行的时间次序
  2. 必须先写日志文件，后对数据库进行操作写入

### 使用日志恢复数据库
1. `Redo`技术
   1. 日志中记录所有数据库修改操作
   2. 发生故障使用 `Redo` 操作重做事务，恢复已完成的事务
2. `Undo`技术
   1. 事务执行过程中修改了数据库而事务还没有提交
   2. 发生故障用 `Undo` 恢复技术撤销事务

## 数据库恢复策略
### 事务故障的恢复
1. 反向扫描文件日志，查找事务更新操作
2. 对更新操作执行逆操作，即将日志记录中更新前的值写入数据库
3. 循环，直到读取到事务开始标记

### 系统故障的恢复
- Undo故障发生时未完成的事务，Redo已发生的事务

1. 正向扫描日志文件
   - Redo队列：故障发生前已经提交的事务
   - Undo队列：故障发生前尚未完成的事务
2. 对Undo队列事务进行`UNDO`处理：反向扫描日志文件，对每个Undo事务的更新操作执行逆操作
3. 对Redo队列事务进行`REDO`处理：正向扫描日志文件，对每个Redo事务重新执行登记的操作

### 介质故障的恢复
- 需要DBA介入，重装数据库恢复到一致性状态后重做已完成的事务

## 检查点恢复技术
- Checkpoint技术允许恢复子系统在登录日志期间动态维护日志，是记录在日志中标识数据库是否正常运行的一个标志
  1. 在日志文件中增加检查点记录
  2. 增加重启动文件（重新开始文件）

在具有检查点技术的数据库系统中，应以此顺序执行操作：写日志$\rightarrow$写检查点记录$\rightarrow$写数据库$\rightarrow$写重新开始文件

- 区别 `REDO` 和 `UNDO`：简单点说就是故障之前提交了就 `REDO`，故障之前没提交就 `UNDO`![](Pasted%20image%2020240505000638.png)

### 检查点记录和重启动文件
- 检查点记录的内容
  1. 建立检查点时刻所有正在执行的事务清单
  2. 这些事务最近一个日志记录的地址

- 重启动文件记录各个检查点记录在日志文件中的地址

### 检查点动态维护日志
1. 把日志缓冲区内容写入日志文件
2. 在日志文件中写入一个检查点记录
3. 把数据库缓冲区的内容写入数据库
4. 把检查点记录在日志文件中的地址写入重启动文件

- 能够改善恢复效率，只运行检查点之后的记录的操作即可

## 数据库镜像恢复技术
主要为处理介质故障，制作数据库镜像(Mirror)，当主数据库更新时，DBMS自动把更新后的数据复制过去

- 出现故障时可以由镜像磁盘继续提供使用，不需要关闭系统
- 不出现故障时可以将镜像用于并发操作

## SQL Server的数据恢复机制
### 数据库完全备份
`EXEC sp_addumpdevice 'disk', 'NwindBac', 'D:\MyBackupDir\NwindBac.bak'` 

`BACKUP DATABASE Northwind TO NwindBac`

### 执行差异备份
还原所需时间较少，用于频繁修改的数据库情况下，只备份上一次完全数据库备份后数据库更改的部分：`backup database <数据库名> <备份位置> with differential`

### 执行事务日志备份
将数据库恢复到特定的即时点或恢复到故障点：`backup log <数据库名> to sp_addumpdevice`

### 执行数据库文件或文件组备份
对于超大型数据库，只备份一部分数据；必须和事务日志备份一起使用，只适用于完全恢复模型和大容量日志记录恢复模型

- 优点：能更快恢复还原损坏文件，同时创建文件和事务日志备份，在调度和媒体处理上具有更大的灵活性
- 缺点：增加了管理的复杂性，即必须维护完整的文件备份集和覆盖的日志备份

必须指定逻辑文件或文件组，最多可以指定16个文件或者文件组；如果创建了索引，必须将几个数据库文件作为一个整体备份

> [!TIPS] 三种恢复模型
> 1. 简单恢复(`set recovery simple`)：允许将数据库恢复到最新的备份
> 2. 完全恢复(`set recovert full`)：允许将数据库恢复到故障点状态
> 3. 批量(大容量)日志记录恢复(`set recovery bulk_logged`)：允许大容量日志记录操作
> 
> ![](Pasted%20image%2020240504031431.png)


### 从完全数据库备份还原
`restore database <数据库名> from <备份名> [恢复选项:recovery|norecovery]`

### 还原事务日志备份
`restore log <数据库名> from <日志名> [恢复选项:recovery|norecovery] stopat={time}`

### 从文件或文件组还原
- 指定要还原的文件`FILE`子句和要还原的文件组`FILEGROUP`子句
- 若创建文件备份后没有对文件进行修改就指定 `recovery` 子句

# 并发控制
---
允许多用户同时使用的数据库系统
## 并发事务运行存在的异常问题（数据不一致性）
主要原因是**并发操作破坏了事务的隔离性**

因此并发控制机制的任务是保证事务的隔离性，使一个用户事务的执行不受其他事务的干扰，避免造成数据的不一致性
### 丢失更新(lost update)
- 两事务从数据库中读入同一事物并修改，同时有一个事务的提交结果破坏了前一个事务的提交结果，导致一个事务的修改丢失

### 不可重复读
- 事务$T_{1}$读取数据后，$T_{2}$对同一数据执行更新操作，使$T_{1}$再次读取该数据时，得到与前一次不同的值

- 幻影现象(phantom row)：$T_{2}$删除或插入了一些记录，使$T_{1}$再次读取数据时某些记录消失或多余

### 读“脏”数据
1. 事务1修改数据并将其写回磁盘
2. 事务2读取同一数据后，事务1由于某种原因被撤销，此时事务1已修改过的数据恢复原值
3. 事务2读到的数据与数据库中的数据不一致，是不正确的数据，又称为“脏”数据

## 并发调度的可串行性
> [!NOTE] 定义
> 多个事务的并发执行是正确的，当且仅当并发执行的结果与这些事务按某一串行顺序执行的结果相同，这种调度策略被称为可串行化调度

- 可串行化使并发事务正确调度的准则
- 可串行性是并行事务正确性的唯一准则

### 调度的冲突等价性
- 从理论上，在某一事务执行时禁止其他事务执行的调度策略一定是可串行化的调度

- 冲突操作：指不同事务对同一个数据的读写操作和写写操作
- 不同事务的冲突操作和同一事务的两个操作不能交换
- 如果一个调度$S$能通过一系列非冲突操作执行顺序的交换变成调度$S_{1}$，则称调度$S$与调度$S_{1}$冲突等价
- 如果一个调度的状态等价于一个串行调度，则称这个调度是状态可串行的

### 调度的状态等价性
- 冲突可串行化调度：一个调度在保证冲突次序不变情况下，通过交换两个事务不冲突操作的次序得到另一个调度，且新调度也是串行的
- 一个调度冲突可串行化，则其一定是状态可串行的(**充分条件**)![](Pasted%20image%2020240504095810.png)

## 基于封锁的并发控制技术
- 并发事务的可串行化技术遵循封锁技术(Locking)约束，即当一个事务存取某一个数据项时，不允许其他事务修改这一数据项

1. 在事务操作某个数据对象之前，先向系统发出请求对其加锁
2. 加锁后，事务就对该数据对象有一定的控制
3. 在事务释放它的锁之前，其他的事务不能更新此数据对象

- 一个事务对某个数据对象加锁后拥有何种控制由封锁的类型决定

### 锁
1. 共享锁(Share lock，S锁，读锁)：在加锁之后其他事务只能再对该数据对象加S锁，在释放之前不能加S锁，且其他事务只能读该对象而不能做任何修改
2. 排他锁(Exclusive lock，X锁，写锁)：只允许当前事务读取和修改，任何事务在释放锁之前都不能对当前对象加任何类型的锁

### 封锁协议
1. 一级封锁协议：事务在**修改**数据前必须先对其加$X$锁，直到事务结束才能释放，**直接保证不丢失修改**
2. 二级封锁协议：在一级封锁协议基础上，事务在**读取**数据前必须先对其加$S$锁，读取完成后释放，目的为**防止读“脏”数据**，但不能保证避免不可重复读的问题
3. 三级封锁协议：在二级封锁协议的基础上，某一事务施加的$S$锁要到事务结束时才释放，目的为**解决不可重复读问题**

### 活锁
- 活锁：在数据库系统中，某事务由于请求封锁但总也得不到锁，而长时间处于等待状态
- 避免活锁的方法：先来先服务，多事务同时请求封锁同一个数据对象时，按先后次序对事务排队；数据对象锁一旦释放，首先批准申请队列中的第一个事务获得锁

### 死锁
同时处于等待状态上的两个或多个事务相互封锁了对方请求的资源，使得都运行不下去，永远等待

#### 预防死锁
1. 一次封锁法：将事务在执行过程中可能要封锁的数据对象全部加锁；但降低了并发度，同时很难事先确定每个事务要封锁的数据对象
2. 顺序封锁法：预先对数据对象规定一个封锁顺序；维护成本高，并且难以实现
3. 事务重试法：使用抢先机制和事务回滚，释放前一个事务的锁并回滚未完成事务，将锁授予后一个事务重试

- 结论：预防死锁不太适合数据库特点

#### 死锁的检测与修复
> 选择一个处理死锁代价最小的事务撤销并回滚，释放此事务持有的所有的锁，使其他事务能继续运行下去

1. 超时法：事务等待时间超过时间阈值就认为发现死锁；实现简单，但有可能误判，且阈值过长有可能不能及时发现死锁
2. 事务等待图法：创建事务等待有向图$G=(V,U)$，若事务$V_{1}$等待$V_{2}$则创建一条由$V_{1}$指向$V_{2}$的有向边，周期性的监测事务等待图中是否存在回路

- 死锁的恢复：回滚一个或多个代价最小的相关事务

### 两阶段封锁协议(2PL)
> [!NOTE] 协议内容
> 1. 在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁
> 2. 在释放一个封锁之后，事务不再获得任何其他封锁

- 两阶段封锁协议是保证并发调度可串行性的封锁协议

1. 一阶段获得封锁(扩展阶段)：可以申请数据项上任何类型的锁，但不能释放任何锁
2. 二阶段释放封锁(收缩阶段)：可以释放数据项上任何类型的锁，但不能申请任何锁

- **所有遵守两阶段封锁协议的事务，其并行执行的结果一定是正确的**，是可串行化调度的**充分条件**

一次封锁法遵守两段锁协议，但遵守两阶段封锁协议的事务可能发生死锁

### 锁表
锁管理器为目前已加锁的数据项维护一个记录链表，每个锁请求为一个记录，按请求到达顺序排序这个表称为缩表(Lock Table)

- 将数据库元素和封锁信息联系在一起

## 多粒度封锁
### 定义
1. 封锁粒度：封锁对象的大小，可以是逻辑单元(属性至数据库)或物理单元(数据页、索引页、物理记录等)

- 多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择

### 选择封锁粒度的原则
- 封锁粒度越大，被封锁对象越少，系统并发度越小，系统开销越小；需要对系统开销和并发度进行权衡
- 处理多个关系的大量元组的用户事务：以数据库为封锁单位
- 处理大量元组的用户事务：以关系为封锁单位
- 处理少量元组的用户事务：以元组为封锁单位

- 多粒度树：以树形结构表示多级封锁粒度，根节点最大的数据粒度

### 多粒度封锁协议
- 允许多粒度树中的每个节点被独立加锁
- 对一个节点加锁意味着其所有子节点也被加以同类型的锁，由于其双亲结点加锁而上锁称为隐式封锁
- 检查封锁冲突时需要检查显式和隐式节点，查看本事务和所有上下级节点是否有显示或隐式冲突

### 意向锁(intention lock)
对任一节点加基本锁，必须先对它的上层节点加意向锁，提高对某个数据对象加锁时的检查效率

1. 意向共享锁(Intent Share Lock，IS锁)：加锁对象表示其子节点拟(意向)加$S$锁
2. 意向排它锁(Intent Exclusive Lock，简称IX锁)：加锁对象表示其子节点拟(意向)加$X$锁
3. 共享意向排它锁(Share Intent Exclusive Lock,简称SIX锁)：表示对它加$S$锁，再加$IX$锁
![](Pasted%20image%2020240504112723.png)

- 例如要对关系R加S锁，只需要对数据库加IS锁，检查数据库和R中是否已经加了不相容的锁，不再需要检查R中的元组

1. 提高系统并发度
2. 减少加锁和解锁的开销

## SQL Server中的并发控制
- 事务提交后，对数据库的修改不立即记录到磁盘上，只改变缓存的内容，到达检查点时才写入磁盘
- 原则是：检查点后提交就重做，检查点后尚未提交就回滚

### 使用事务的指导方针
1. 尽可能短，并避免嵌套事务
2. 用户输入应该在事务开始前进行，事务期间不等待用户输入
3. `insert, update, delete` 是事务主要语句，应尽可能少地改变数据行
4. 尽可能减少对数据访问，减少锁定表的数目

### 显性隐性事务
事务中包含多条语句需要用 `begin tran` 和 `commit tran`(或 `rollback tran`)包围起来，称为显式事务

默认情况下SQL Server将每一条语句视为独立事务，执行后立刻提交，称为隐性事务

### SQL Server的锁定
- 可以锁定的项目类型：![](Pasted%20image%2020240504114415.png)
- 可以用 `sp_lock` 命令查看锁的信息

- 更新锁：用于可更新资源，防止多会话读取锁定造成死锁；是S锁和X锁的混合，能提高并发度；更新锁与S锁兼容
- 架构锁：确保表或索引在被另外会话引用时不被删除或更改架构，包括架构稳定性(Sch-S)锁和架构修改(Sch-M)锁

### 事务的隔离级别
事务准备接受不一致数据的级别称为隔离级别，是一个事务必须与其他事务进行隔离的程度

- 隔离级别：
  1. 未提交读(最低级别，仅保证不读取物理损坏数据)：不使用共享锁，允许脏读
  2. 提交读(默认级别)：读取时使用共享锁，不允许脏读
  3. 可重复读：不可能发生脏读和不可重复读，保持读锁直到事务结束
  4. 可串行读(最高级别，事物之间完全隔离)：不可能发生幻象读

# 关系数据库设计理论
---
## 关系模型的存储异常
关系数据库模式的设计，即数据库的逻辑设计就是要从各种可能的关系模式组合中选取一组关系模式来构成一个数据库模式

- 实体和实体间以及实体内部的属性值之间存在着相互依赖又相互制约的关系，称为**数据依赖**

## 函数依赖
反映关系中属性间的制约关系
### 函数依赖
> [!NOTE] 定义一
> 设关系模式$R(U), X,Y\subseteq U$，$r$是$R(U)$上的任一关系。对任意元组$t_{1},t_{2}\in r$，如果两元组在$X,Y$上的属性值都相等，则称$X$函数决定$Y$，或$Y$函数依赖于$X$，记为 **$FD X\rightarrow Y$**，称$X$为决定因素(函数依赖左部)，$Y$为函数依赖的右部
> 
> 设$FD X\rightarrow Y$，若$Y\subsetneq X$，则称为非平凡的函数依赖；否则为平凡的函数依赖

- 函数依赖是指关系模式中**所有关系示例**均要满足的约束条件
- 任一关系模式平凡函数依赖都是必然成立的

> [!NOTE] 定义二
> 设关系模式$R$，$X,Y,Z$是$R$的属性子集，若$FD X\rightarrow Y,~Y\nrightarrow X,~Y\rightarrow Z$，则必有$FD X\rightarrow Z$，则称$FD X\rightarrow Z$为传递函数依赖

## 关系模式的规范化
通过分解关系模式消除不合适的数据依赖，解决插入异常、删除异常、更新异常和数据冗余问题；为解决**存储异常**问题引入的
### 第一范式
- 如果关系模式$R$中的每一个属性对应的域值都是不可再分的，则称模式$R$属于第一范式，简记为$R\in 1NF$
- 不满足1NF的数据库模式不能称为关系数据库

### 第二范式
- 如果一个关系模式$R\in 1NF$，且所有非主属性都完全依赖于$R$的每个候选键，则$R\in 2NF$
  - 人话版：决定关系没有多对一；或者有多对一，但是决定因素的子集没有对应的关系
![](Pasted%20image%2020240504133136.png)
- 将一个1NF的关系分解为多个2NF的关系，可以一定程度上解决问题

### 第三范式
- 设$R\in 1NF$，若在$R$中没有非主属性传递依赖与$R$的候选键，则关系模式$R\in 3NF$
  - 人话版：没有非主属性对候选键的传递函数依赖
 
- 2NF的关系模式不一定属于3NF，但是3NF的关系模式一定属于2NF

> 若$R\in 3NF$，则$R$的每一个非主属性既**不部分函数依赖**于候选键也**不传递函数依赖**于候选键

### Boyce-Codd范式(BCNF)
> [!NOTE] 定义
> 若$R\in 1NF$，而且$R$中没有任何属性传递依赖于$R$中的任一关键字，则关系模式$R\in BCNF$
> 
> 另一个更为直观的BCMF定义：对于$R$上的函数依赖集中的每一个函数依赖$X\rightarrow$，必有$X$是$R$的一个候选键

- BCNF不仅排除了非主属性对主属性的传递依赖，也排除了主属性之间的传递依赖
- 只考虑函数依赖，BCNF是关系模式规范化的最高程度

## 多值依赖和4NF
### 多值依赖
> [!NOTE] 定义
> 设$R(U)$是一个关系模式，$X,Y$是$U$的子集，且$Z=R-X-Y$。$r$是$R$上的一个关系，当且仅当对于一个给定的$x$值，有一组$y$的值，且这组$y$值与$r$中的其他属性$Z$无关，则称$X$多值决定$Y$或$Y$多值依赖于$X$，记为$$X\rightarrow\rightarrow Y$$若$Z=\emptyset$，则称$X\rightarrow\rightarrow Y$为**平凡的多值依赖**

### 4NF
- 超键：能够唯一标识元组的属性集合，其中可以包含候选键
- 对于$R$上的任何一个非平凡的多值依赖$X\rightarrow\rightarrow Y$，$X$是$R$的一个超键，则$R\in 4NF$
- 考虑多值依赖，4NF是关系模式规范化的最高程度

## 函数依赖公理
设函数依赖集$F$，所有被$F$逻辑蕴含的函数依赖称为**F的闭包**，记为$F^{+}$
### Armstrong公理
- 设关系模式$R(U, F)$，并且$X,Y,Z$和$W$是$U$的子集
  1. A1自反律(Reflexivity)：若$Y\subseteq X\subseteq U$吗，则$F|=X\rightarrow Y$
  2. A2增广律(Augmentation)：若$X\rightarrow Y$且$Z\subseteq U$，则$F~|=XZ\rightarrow YZ$
  3. A3传递律(Transitivity)：若$X\rightarrow Y,Y\rightarrow Z$，则$F|=X\rightarrow Z$

- 导出推论：
  1. 合成规则：由$X\rightarrow Y$，$X\rightarrow Z$，则$X\rightarrow YZ$ (A2, A3)
  2. 分解规则：由$X\rightarrow Y$及$Z\subseteq Y$，则$X\rightarrow Z$ (A1, A3)
  3. 伪传递规则：由$X\rightarrow Y$，$YZ\rightarrow W$，则$XZ\rightarrow W$ (A2, A3)

### 属性闭包
- 求属性闭包的方式：![](Pasted%20image%2020240504144431.png)

### 函数依赖集的等价和覆盖
如果$G^{+}=F^{+}$，就说函数依赖集$F$覆盖$G$，或$F$与$G$等价

- 最小依赖集：右部都是单属性，所有函数依赖都是不可或缺的，删掉后就不等价了
- 最小函数依赖集$F_{m}$不一定是唯一的

#### 极小化过程
1. 将所有函数依赖转换为右部单属性的
2. 分别去掉一个函数依赖$X\rightarrow A$后求关于$X$的闭包，去掉多余的函数依赖
3. 去掉函数依赖左部多余的属性：检查形如$B_{1}B_{2}\cdots B_{m}\rightarrow A$的函数依赖，若$A\in(X-B_{i})_{F}^{+}$，则以$X-B_{i}$取代$X$

# 数据库设计
---
## 数据库设计方法
### 数据库设计过程
1. 需求分析(基础，最困难、耗时)：建立数字字典
2. 概念结构设计(关键)：对用户需求综合归纳，形成独立于具体DBMS的概念模型，E-R图
3. 逻辑结构设计：将概念结构转换为某个DBMS所支持的数据模型并优化，在基本表基础上建立必要的视图(View)，形成数据外模式；设计关系模式
4. 数据库物理设计阶段：选取存储结构和存取方法，建立索引，形成数据库内模式
5. 数据库实施阶段：
6. 数据库运行和维护：

- 在概念结构设计中，将各个分E-R图中的实体集成时需要消除三类冲突，分别是**属性冲突、命名冲突和结构冲突**