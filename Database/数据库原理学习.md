# 数据库系统引论
---
## 数据库系统结构
### 数据库系统的三级模式结构
1. Schema(逻辑模式)：应用DDL语言(Database Description Language)，全体数据逻辑结构和特征的描述，构成了数据库的总体框架
2. External Schema(Subschema)：外模式是用户能看见的局部数据的逻辑结构和特征，是与某一应用具体相关的数据逻辑表示；不同用户有不同的外模式，保障数据安全性；介于模式与应用之间
3. Interal Schema(内模式)：存储模式，一个数据库只能有一个，是整个数据库实际存储的表示
![](Pasted%20image%2020240228090112.png)
### 三级模式结构的二级映像
- 数据库系统的三级模式是对数据的三个抽象级别：**视图级、概念级和物理级**，它使用户能逻辑地抽象地处理数据，而不必关心数据在计算机内部的存储方式，把数据的具体组织交给DBMS管理
- 外模式与模式之间的映像定义局部数据逻辑结构与全局逻辑结构的对应关系，实现了数据的**逻辑独立性**：一个模式对应多个外模式。当模式结构改变，则只要修改外模式与模式间的对应关系，而不必修改外 模式中的局部逻辑结构，因而相应的应用程序亦可不必修改
- 模式与内模式之间的映像定义全局数据逻辑结构和物理数据存储的对应关系，提供了数据的**物理独立性**：一个模式对应一个内模式。当数据库的物理存储结构改变时，仅需要修改模式与内模式间的映像关系，而可以使模式保持不变，从而使应用程序保持不变

## 数据库管理系统

### 数据库管理系统的功能

#### 定义功能
1. 模式定义语言(DDL)：定义数据库全局逻辑结构，定义记录型和记录的数据项信息，说明数据之间的联系
2. 外模式定义语言：定义用户的局部逻辑结构，形式功能与DDL基本相同
3. 内模式定义语言：定义物理数据库的结构，包括数据的存储方式、存取方式和检索技术、以及对数据的分区分页

#### 操作功能
数据操纵语言(Data Manipulation Language, DML)实现对数据库的**插入、删除、修改、查询**操作

#### 保护功能
安全性、完整性控制、并发控制和恢复

## 数据库系统的不同视图
数据库的相关人员主要分为四类：**数据库管理员（DBA）、系统分析员、应用程序员和用户**

不同人员涉及数据的抽象级别不同，因而具有不同的数据库视图![](Pasted%20image%2020240228104620.png)
1. 数据库管理员（DBA）：决定数据库中的信息内容和结构、存储结构和存取策略、监控运行安全性以及数据库的改进重组
2. 系统分析员：负责应用系统的需求分析和规范说明，与用户和DBA协商确定硬软件配置，参与数据库的概要设计
3. 数据库设计人员：确定数据，调查用户分析，设计数据库各层模式
4. 应用程序员：设计编写应用系统模块，进行调试安装
5. 用户：偶然、简单和复杂用户

# 数据模型
---
数据模型是数据特征的抽象，用来描述数据的一组概念和定义，包含**数据结构、数据操作和数据的完整性约束**三部分

1. 数据结构：描述数据库组成对象以及对象之间的联系，通常按照数据结构的类型命名数据模型，描述系统静态特性
2. 数据操作：对数据库中各种对象实例允许执行的操作，描述系统动态特性
3. 数据的完整性约束：保证数据的正确、有效和相容

## E-R(Entity-Relationship)概念模型
### 概念定义
1. 实体(Entity)：客观存在并且相互区别的事物，可以是具体对象或抽象概念；具有同类特征的实体集合称为实体集
2. 属性(Attribute)：实体特征称为属性，实体可由若干个属性来刻画；属性分为“类型”和“值”：类型即属性名，属性值的集合构成了一个学生实体
3. 联系(Relationship)：实体之间的联系(不同实体集的联系)，事物内部的联系(实体内部属性之间的联系)；有一一(1: 1)对应、一对多(1: n)和多对多(m: n)等

### E-R图
1. 实体用矩形框表示，属性用椭圆形表示
2. 实体之间的联系用菱形框表示，连线旁标明实体间联系的类型

### 联系
1. 基数比约束：即上文提到的一一(1: 1)对应、一对多(1: n)和多对多(m: n)等
2. 参与约束：一个实体集中的所有实体都参与联系称为完全参与，否则称为部分参与
3. 实体参与度：实体参与联系的最小和最大次数，称为实体的参与度
4. 弱实体：依赖其他实体存在的实体，E-R图中用双框矩形表示，表示全部参与时与菱形用双线连接
5. 子类实体：将一个实体集根据个体的不同特性分为多个子集（有点像Java的子类那种）

### 优势
1. 用户需求不变的情况下，模型稳定
2. 能够方便的转化为具体的DBMS所支持的数据模型

## 层次模型
> [!NOTE] 定义
> 用树型结构表示各类实体以及实体间的联系
> 1. 有且只有一个节点且没有双亲结点(根节点)
> 2. 根节点以外的其他节点有且只有一个双亲结点

### 优势
1. 数据结构简单清晰
2. 查询效率较高
3. 提供了良好的数据完整性支持

### 缺陷
1. 不能直接表示两个以上实体型之间的复杂联系以及实体型之间的多对多联系
2. 对数据插入和删除操作限制过多
3. 查询子女节点必须通过双亲结点

## 网状模型
两个或两个以上的节点都可以有多个双亲结点，有向树变成了有向图

### 优点
1. 一个节点有多个双亲的特性更加符合现实世界的关系规则
2. 具有良好的性能，存取效率高

### 缺陷
1. 结构复杂，且随数据量增加复杂程度不断上升，不利于最终用户掌握
2. DDL和DML语言复杂，且访问数据时必须自己选择路径，程序编写有负担

## 关系模型

### 基本概念
基本数据结构被限制为二维表，一个二维表称为一个关系
1. 关系：
   1. 关系(relation)：一个关系可用来表述一个实体集，是一张由行列组成的二维表
   2. 属性(attribute)：每一列为关系的一个属性
   3. 域(domain)：一个属性对应一个值的集合，即域是属性的取值范围，如学号的域为10位数字的集合
   4. 元组(tuple)：关系是元组的集合，一个元组对应实体集的一个个体，可以理解为一条数据
   5. 键(key)：键是由一个或多个属性组成等，能够唯一识别一个元组

2. 关系模式(relation schema)
   1. 关系名(属性1，属性2，$\cdots$，属性n)
   2. **关系数据库模式**是一组关系的集合，这组关系模式对应的关系集合称为关系数据库
   3. 关系模型中基本的数据结构是单一的关系
   4. 关系必须是规范化的，最基本条件即为关系的每一个分量必须是一个不可再分的原子数据项

3. 数据完整性约束
   - 实体完整性、参照完整性、用户自定义完整性

4. 数据操纵
   1. 对数据的查询、插入、删除和修改操作；可以进行多种运算，运算结果又构成新的关系
   2. 关系运算分为关系代数和关系演算

### 关系模型的优势
1. 数据结构简单
2. 一体化数据子语言
3. 数据独立性搞
4. 面向集合的存取方式
5. 坚实的理论基础
6. 有利于开展其他应用


# 关系数据库
---
> [!NOTE] 定义
> 支持关系模型的数据库系统
> 
> 由数据结构、数据操作和完整性约束构成

## 关系模型的基本概念

### 关系的定义
1. 域(domain)：一组具有相同数据类型值的集合，表示属性的取值范围，如$D_{2}=\{male, female\}$，$D_{2}$为域名
2. 笛卡尔积(Cartesian Product)：给定一组集合$\{D_{1},D_{2},\cdots,D_{n}\}$，则集合的笛卡尔积表示为：$$D_1\times D_2\times...\times D_n=\{(d_1,d_2,...,d_n)\mid d_i\in D_i,i=1,2,...,n\}$$表示的是域中所有取值的组合(不能重复)
3. 元组(tuple)：笛卡尔积中每一个元素$(d_{1},d_{2},\cdots,d_{n})$叫做一个$n$元组，简单理解就是任意一种组合
4. 分量(Component)：笛卡尔积元素$(d_{1},d_{2},\cdots,d_{n})$中每一个$d_{i}$叫做一个分量，简单理解就是元组中的一个变量

#### 关系
> [!NOTE] 定义
> $D_1\times D_2\times...\times D_n$的任一个子集称为$\{D_{1},D_{2},\cdots,D_{n}\}$上的一个关系。$N$叫做关系的目或度(degree)

关系中的每一行对应一个元组，通常用$t$表示；每一列对应一个域，关系中的列称为属性，每一列用属性名表示。其中$t[A_{i}]$表示元组$t$在属性$A_{i}$上的值

从笛卡尔积中取出实际有意义的元组构造关系

 严格来说，关系是一种规范化后的二维表中的集合，为了使相应的操作简化对关系加入了限制：例如限定有限数据，为关系每列添加属性以取消有序性等

#### 规范化关系性质
1. 列的同质性(Homogeneous)：每一列中的分量是同一类型的数据，来自同一个域
2. 不同的列可以出自同一个域：不同的属性必须有不同的属性名
3. 行、列的顺序无关
4. 关系中不能出现重复的元组
5. 分量必须取原子值

### 关系模式和关系数据库
- 关系的型称为关系模式(relation schema)，是对关系的描述，一般简记为关系名和属性名的集合
- 关系是值，是元组的集合
- 关系模式的集合称为关系数据库模式，是对数据库中所有数据逻辑结构的描述
- 关系数据库模式中的每个关系模式上的关系的集合称为关系数据库

### 键
> [!NOTE] 定义
> 为区分不同元组，能够唯一标识元组的属性或属性组成为关系的键
> 
> - 其中能够起表示作用的键称为候选键
> - 若有多个候选键，则选一个键作为主键(primary key)
> - 关系键由多个属性组成称为联合键
> - 关系中的所有属性构成关系的键，称为全键

### 完整性约束
1. 实体完整性约束(Entity Integrity Constraint)
   1. 主键的值不能为空或部分为空
   2. 元组键为空将导致元组不可标识，不能表示任何实体，没有意义
2. 参照完整性约束(Reference Integrity Constraint)
   1. 是对关系中作为外键的值的约束

## 关系代数
> [!NOTE] 定义
> 抽象的查询语言，用对关系的运算来表达查询
> 
> 三要素：运算对象、运算结果、运算符

- 运算符分类：
  1. 传统的集合运算：并、差、交、广义笛卡尔积
  2. 专门的关系运算：选择、投影、连接、除，涉及行列运算，是专门为数据库应用而引进的特殊运算

### 传统集合运算
$R$ 和 $S$具有相同的目$n$(即两个关系都具有$n$个属性)，且相应的属性取自同一个域

#### 并运算(Union)
- $R\cup S$仍为$n$目关系，由属于$R$或属于$S$的元组构成，即$$R\cup S=\{t\in  R\vee t\in S\}$$
#### 差运算(Difference)
- $R\cup S$仍为$n$目关系，由属于$R$而不属于$S$的元组构成，即$$R-S=\{t~|~t\in  R\wedge t\notin S\}$$

#### 交运算(Intersection)
- $R\cup S$仍为$n$目关系，由既属于$R$也属于$S$的元组构成，即$$R\cap S=\{t\in  R\wedge t\in S\}$$
- 交运算也可以用差运算来表示，即$R\cap S=R-(R-S)$

#### 笛卡尔积
- $R$中所有元组与$S$中所有元组的拼接，即$$R\times S=\{\widehat{t_\mathrm{r}t_\mathrm{s}}\mid t_\mathrm{r}\in{R}\wedge t_\mathrm{s}\in{S}\}$$![](Pasted%20image%2020240302223122.png)

### 专门关系运算
#### 选择(Selection)
- 从关系中选择满足一定条件的元组子集$$\sigma_{{F}}({R})=\{t\mid t\in{R}\wedge t({F})\}$$其中$F$是限定条件的布尔表达式，由逻辑算符连接比较表达式组成
- 从行的角度进行运算，选择在关系$R$中使$t(F)$为真的所有元组

#### 投影(Projection)
- 模式$R$上的投影运算表示为$$\prod_x({R}){=}\{{t}[{X}]\mid{t}{\in}{R}\}$$其中$\prod$是投影算符，$X$是模式$R$属性的子集，$t[X]$表示$R$中元组在属性集$X$上的值，或为元组$t$在$X$上的投影
- 从列的角度进行运算，从$R$中选出若干属性列组成新的关系

#### (内)连接(Join)
##### 条件连接($\theta$连接)
> [!NOTE] 定义
> 将两个关系中满足$\theta$条件的元组拼接起来形成新元组的集合
>  设属性$A$和$B$分别是关系$R$和$S$上的属性，且定义在同一个域上，$R$和$S$的连接记为：$$R \bowtie_{A\theta B}S~\{\mathrm{t}\mid t=\overset{{\frown}}{{t_r}{t_s}},\mathrm{t_r}\in\mathrm{R}\wedge\mathrm{t_s}\in\mathrm{S}\wedge\mathrm{t_r}[\mathrm{A}]~\mathrm{\theta}~\mathrm{t_s}[\mathrm{B}]\}$$其中，$\bowtie$是连接符，$A\theta B$是连接条件，$\theta$是比较符


- 即从两关系的笛卡尔积中选取两者关系满足连接条件的元组
- 最常用的连接是两个属性值相等的比较，称为等值连接，即$\theta$为$=$

##### 自然连接
> [!NOTE] 定义
> 一种特殊的等值连接，要求两关系中进行比较的分量必须是**相同的属性组**，并且在结果中把重复的属性列去掉
> $$R\bowtie S=\{t~|~t=\overset\frown{t_{r}t_{s}}[\bar{A}],~ t_{r}\in R\wedge t_{s}\in S\wedge t_{r}[A] = t_{s}[A]\}$$

如下图所示，去掉了相同的$R.B$和$S.B$列并合并为$B$列![](Pasted%20image%2020240303182832.png)

#### 除(Division)
> [!NOTE] 定义
> 进行除法运算$\div$，要求两关系有定义在同一域上的属性或属性组；$R\div S$的结果生成一个新关系$R^{\prime}$，$R^{\prime}$的属性是$R$的属性中去掉与$S$具有公共域属性的其他属性
> j
> 设$R(X,Y),~S(Y),~R^{\prime}(X)$，则$R\div S$记为：$$R\div S=R^{\prime}=\{t~|~t\in R^{\prime} \wedge t_{r}\in R \wedge t_{s}\in S\wedge t_{r}[R^{\prime}]=t\wedge t\bowtie S\subseteq R\}$$

如下图，即筛选出$R$中所有$B、C$ 两列全部符合$S$的$A$属性 ![](Pasted%20image%2020240303185815.png)

### 扩充的关系运算
#### 属性重命名
> [!NOTE] 定义
> $$r^{\prime}({R}^{\prime})={\delta}A{\rightarrow}{B}(r)$$其中$A$表示模式$R$中的原属性，$B$表示重命名后的属性，$r$是模式$R$中的一个关系

- 重命名运算可以同时对一组属性进行操作
- 通过重命名运算，可以
  1. 在同一个关系上做自然连接运算
  2. 做同一个关系的笛卡尔积
  3. 将两关系的等值连接方便的表示为自然连接

#### 外连接(Outer join)
> [!NOTE] 定义
> 对自然连接的拓展，连接结果中除了满足连接条件的元组外还包含没有被连接的元组

- 左外连接：连接结果包含了关系$R$(左边关系)中不满足连接条件的元组，这些元组对应关系$S$属性上的值为空值，记为$R\bowtie_{L}S$![](Pasted%20image%2020240303195819.png)
- 右外连接：连接结果包含了关系$S$(右边关系)中不满足连接条件的元组，这些元组对应关系$R$属性上的值为空值，记为$R\bowtie_{R}S$
- 完全外连接：连接结果同时包含了关系$R$(左边关系)和关系$S$(右边关系)中不满足连接条件的元组。即连接结果是左外连接和右外连接的并，记为$R\bowtie_{F}S$

# 关系数据库标准语言SQL
---
## SQL的简介
> [!SUMMARY] 定义
> SQL语言是一种介于关系代数与关系演算之间的语言，是通用、功能极强的关系数据库语言

- SQL的特点：
  1. 综合统一：集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)的功能于一体，能完成数据库生命周期中的全部活动；同时实体间的联系都用关系表示，操作符单一，每种操作只使用一种操作符
  2. 高度非过程化：只需指出“做什么”，无需了解存储路径，提高数据独立性
  3. 面向集合的操作方式：查询、插入、删除和修改操作面向的对象都是集合
  4. 以同一种语法结构提供多种使用方式，不同方式下的语法结构基本一致

## SQL的系统结构
- SQL中的关系模式称为基本表(Table)，基本表的集合构成数据库的模式，对应三级模式结构的模式
- 基本表在物理上与存储文件相对应，所有存储文件的集合为物理数据库
- 外模式（由试图(View)组成）
![](Pasted%20image%2020240317190007.png)
## SQL的数据定义
> [!NOTE] 主要内容
> SQL的数据定义主要包括定义表、定义视图和定义索引，在SQL2中还增加了对数据库模式的定义![](Pasted%20image%2020240317190435.png)

### 模式的定义和删除
- SQL模式由**模式名、权限标识符和模式中元素的描述符**组成
  1. 权限标识符指明拥有该模式的用户或账号
  2. 模式元素包含一个数据库应用的表、视图和索引等
#### 模式定义
- 在定义模式时先给出模式名和权限标识符：`CREATE SCHEMA <模式名> AUTHIRUZATION <用户名>`
- 也可以在模式定义中进行创建表、视图和定义授权等操作
#### 模式删除
- 删除模式语句：`DROP SCHEMA <模式名> [CASCADE | RESTRICT]
  - `CASCADE`(级联式)方式：在删除模式的同时把该模式中的对象全部一起删除
  - `RESTRICT`(限制式)方式：如果该模式已经定义了下属的数据库对象，则拒绝该删除语句的执行

### 基本表的定义、删除与修改
#### 定义基本表
> [!NOTE] 基本语法
> `CREATE TABLE <table name> (<row name> <data type> [列级完整性约束条件] [表级完整性约束条件])`

1. 表名：所定义的基本表名字
2. 列名：组成该表的各个属性(列)
3. 完整性约束条件：
   - 列级完整性约束条件：涉及相应属性列的完整性约束条件
   - 表级完整性约束条件：涉及一个或多个属性列的完整性约束条件
   - 语法为 `constraint <约束名> <约束>`

- 通过 `create table <模式名>.<表名> (...)` 语句格式可以在定义表的同时指定所属的数据库模式名

#### 修改基本表
> [!NOTE] 基本语法
> `ALTER TABLE <table name> [ADD <row name> <data type> [完整性约束]] [DROP <row name> [CASCADE | RESTRICT]] [ALTER <row name> <data type>]`

- `DROP`子句用于删除指定的列名，`RESTRICT`表示必须没有视图和约束引用时才能删除该列
- `ALTER`子句用来修改列的定义，如修改列的数据类型、宽度等

#### 删除基本表
> [!NOTE] 基本语法
> `DROP TABLE <table name> [RESTRICT | CASCADE]`

- 默认约束参数为`RESTRICT`，即不能被其他表参数所引用（如`check`，`foreign key`等）

### 索引的建立与删除
建立索引是加快数据查询速度的有效手段
#### 建立索引
> [!NOTE] 语句格式
> `CREATE [UNIQUE] [CLUSTER] INDEX <index name> ON <table name> (<row name> [<次序>])`

- 索引名可以建立在数据表的一列或多列上，各列名之间用逗号分隔
- `<次序>`指定索引值的排列顺序，其中`ASC`表示升序，`DESC`表示降序，默认参数为`ASC`
- `UNIQUE`表明此索引的每一个索引值只对应唯一的数据记录，对于已经含有重复值的属性列不能建立，同时插入新纪录时DBMS也会自动检测新纪录在该列上是否取了重复值
- `CLUSTER`表示要建立的索引是聚簇索引
  1. 非聚簇索引：数据存储在一个位置，索引存储在另一个位置，索引带有指针指向数据的存储位置
  2. 聚簇索引：对表的物理数据按列进行排序，即索引与数据是一体的，叶节点存储的就是本身的数据
  - 聚簇索引直接确定表中数据的物理顺序，因此一个表中只能有一个聚簇索引；适用于很少对基表进行增删，同时对经常要搜索范围值的列尤其有效
  
#### 删除索引
> [!NOTE] 基本语法
> `DROP INDEX <index name>`

### 索引选择
1. 对某个属性使用索引能极大提高对属性上值的检索效率
2. 但带索引的表占用空间更大，维护索引和对数据进行操作会花费更长时间

- 建立索引：查询操作相比于更新操作更多的属性，经常查询`where`子句中常量进行比较的属性，频繁出现在连接条件中的属性
- 不建立索引：更新操作比较频繁

## SQL的数据操纵
### 数据查询
> [!NOTE] 语句格式
> `SELECT [ALL | DISTINCT] <目标列表达式>`
> 	   `FROM <表名或视图名>`
> 	   `[WHERE <条件表达式>]`
> 	   `[GROUP BY <列名1> [HAVING <条件表达式>]]`
> 	   `[ORDER BY <列名2> [ASC | DESC]]`

- `SELECT`：指定要查询的属性列
- `FROM`：指定查询对象（基本表、视图）
- `WHERE`：指定查询条件
- `GROUP BY`：对查询结果按照指定列经`HAVING`语句筛选后的值进行分组，该属性列值相等的元组为一个组
- `ORDER BY`：对查询结果表按指定列值进行升降序排列

#### 单表查询
- 应用列别名`select <row name> as <bios name>`改变查询结果的列标题
- 使用`DISTINCT`短语消除查询结果中取值重复的行，要注意作用范围是所有目标列，因此不对每一列使用而对整个命令使用

##### WHERE子句常用的查询条件
![](Pasted%20image%2020240318110926.png)
值得注意的是字符串匹配操作中`EACAPE`操作：`WHERE Cname LIKE 'DB\_%i__’ ESCAPE '\'`

##### 使用集函数
如`count, max, min, avg, sum`等，应用类似`SELECT COUNT(DISTINCT Sno) FROM SC`等语句进行计数和求解相关值操作

##### 对查询结果分组
> [!TIPS] 基本语法
> 1. 使用`WHERE`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderhist WHERE productid = 2 GROUP BY productid`
> 
> 2. 使用`HAVING`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderlist GROUP BY productid HAVING SUM(quantity)>=30`

- `WHERE`和`HAVING`语句的区别
  1. 作用对象：`WHERE`作用于基表或视图，选取满足条件的元组；`HAVING`作用于组，选择满足条件的组；可以从与`GROUP BY`的位置关系理解
  2. `WHERE`语句不能使用聚集函数，`HAVING`可以

#### 连接查询
1. 自然连接：等值连接的一种特殊形式，会自动删去重复的行 `SELECT buyer_name, sales.buyer_id, qty FROM buyers, sales WHERE buyers.buyer_id = sales.buyer_id`
2. 自身连接：由于连接的双方完全是同一个表，因此必须起别名加以区分
3. 外连接：相较于内连接的区别在于同时将主体表中不满足连接条件的关系一并输出 `SELECT Student.Sno, Cno FROM Student LEFT JOIN SC ON (Student.Sno = SC.Sno)`，也会输出Sno并不对应的Student表中的关系

#### 嵌套查询
> [!NOTE] 定义
> 将一个查询块嵌套在另一个查询块的`WHERE`子句或`HAVING`短语的条件中的查询称为嵌套查询
> 
> - 子查询不能使用 `ORDER BY` 子句

- 不相关子查询：嵌套查询从里向外进行，即将子查询运算的结果作为父查询的条件
- 相关子查询：取外层查询中表的第一个元组，若内层查询返回结果为`TRUE`则将元组放入结果表

##### 子查询的谓词
1. 带有`IN`谓词的子查询(不相关子查询)：`SELECT <row name> FROM <table name> IN (SELECT <row name> FROM <table name> WHERE ...)`
2. 带有比较运算符的子查询：**子查询一定在比较符之后**，比较特殊的是`<>`等价于`!=`
3. 带有`ANY`或`ALL`谓词的子查询：
   - `ANY`：任意一个值；`ALL`：所有值
   - 跟在比较运算符后面用，类似于 $\exists$ 和 $\forall$
   - 有些时候可以用集函数替代，如 `< ANY` 等价于 `< MAX`，一般用集函数效率更高，能减少比较次数
4. 带有`EXISTS`谓词的子查询：子查询只返回逻辑真假值TRUE或FALSE

#### 集合查询
标准SQL直接支持的只有并(UNION)操作，其余一般支持种类还有交(INTERSECT)、差(EXCEPT/MINUS)等

**属性个数必须一致，对应类型必须一致，与属性名无关，默认去掉重复元组**

##### 并操作
`SELECT * FROM Student WHERE Sdept= 'CS' UNION SELECT * FROM Student WHERE Sage<=19 ORDER BYSageDESC`

##### 交操作
`(SELECT * FROM Student WHERE Sdept='CS') INTERSEC (SELECT * FROM Student WHERE Sage<=19) ORDER BY Sage DESC`

##### 差操作
`SELECT Sno FROM SC WHERE Sno IN (( SELECT Sno FROM SC WHERE Cno='1') EXCEPT ( SELECT Sno FROM SC WHERE Cno='2'))`

##### 对集合操作结果的排序
只能对**最终查询结果**排序，不能对中间结果排序；任何情况下`ORDER BY`子句都只能出现在最后

> [!IMPORTANT] SELECT语句的一般形式
> `SELECT [ALL|DISTINCT] <目标列表达式> [别名] [，<目标列表达式> [别名]] … FROM <表名或视图名> [别名] [，<表名或视图名> [别名]] … [WHERE<条件表达式>] [GROUP BY<列名1>[，<列名1>] ... [HAVING <条件表达式>]] [ORDER BY<列名2> [ASC|DESC] [，<列名2’> [ASC|DESC] ] … ]；`

### 数据更新
#### 插入数据
1. 插入单个元组：`INSERT INTO <table name> [属性列] VALUES(常量)` 
   1. `INTO`子句：指定插入数据的数据表和属性列，属性列顺序可以与表不一致；不指定属性列表示插入完整元组，指定部分属性列表示其余为空值
   2. `VALUES`子句：提供的值的类型和个数必须与`INTO`子句匹配
2. 插入子查询结果：`INSERT INTO <table name> [属性列] <select 语句>`

#### 修改数据
> [!NOTE] 语句格式
> `UPDATE <表名> SET 列名1=<表达式1>[,列名2=<表达式2>]...[WHERE <条件表达式>]`
> 1. `SET`子句：指定修改方式：要修改的列和修改后的值
> 2. `WHERE`子句：指定要修改的元组，无参数默认修改全部元组

#### 删除数据
`DELETE FROM <表名> [WHERE<条件>]`

## SQL中的视图
> [!NOTE] 定义
> 视图提供了一种观察数据的逻辑窗口，对视图的操作也是对基表进行相对应的操作。

### 视图的定义
#### 建立视图
> [!NOTE] 基本语句
> `CREATE VIEW <视图名> [列名] AS <子查询> [with check option]`
> - 其中`SELECT`语句表示子查询，但一般不包括`ORDER BY`子句和`DIStiNCT`短语
> - `WITH CHECK OPTION`：在通过视图执行增删改查操作时，不得破坏视图定义的谓词条件(即子查询的条件表达式)

- 组成视图的属性列名全部省略或全部指定
  - 省略: 由子查询中SELECT目标列中的诸字段组成 
  - 明确指定视图的所有列名: 
    1. 某个目标列是集函数或列表达式 
    2. 目标列为$*$
    3. 多表连接时选出了几个同名列作为视图的字段
	4. 需要在视图中为某个列启用新的更合适的名字

- 需要注意的是带表达式的视图必须明确定义组成视图的各个属性列名，如 `CREATE VIEW D-Sage(Sdept, Avgage) AS SELECT Sdept, AVG(Sage) FROM Student GROUP BY Sdept`

- 应尽可能避免以 `SELECT *` 方式创建的视图，因为当修改基表的结构时视图与基表的映像关系会被破坏，不宜扩充

#### 删除视图
`DROP VIEW <视图名>`

删除基表时，由该基表导出的所有视图定义都必须显式删除

### 视图上的的操作

- DBMS实现视图查询的方法
  1. 实体化视图(View Materialization)：执行有效性检查，进行视图定义将视图实体化(临时表)，并在查询工作中转化为查询临时表
  2. 视图消解法(View Resolution)：执行有效性检查，把视图定义中的子查询与用户的查询结合起来转化为对基本表的查询
     - 即会将操作结合基表的限制条件转化对为最底层表的查询操作

#### 查询
- 原查询：`SELECT * FROM Sage_23 WHERE Sdept='计算机'`
- 转换后的查询：`SELECT * FROM Student WHERE Sdept='计算机' AND Sage < 23`

#### 更新(即增删改)
插入`INSERT`，删除`DELETE`，更新(已有关系元组的信息)`UPDATE`

#### 视图的优点
1. 提供了数据的逻辑独立性：通过建立一个视图，使用户的外模式不变；从而当数据库逻辑结构发生改变时，对原表的查询程序不需要进行修改
2. 简化用户视图：如基于多张表的连接形成的视图，复杂嵌套的视图等
3. 使用户以不同角度看待相同的数：适应数据库共享的需要
4. 提供了安全保护功能：使不同用户只能看到他有权看到的数据

## SQL的数据控制
### 授权
> [!NOTE] 语句格式
> `GRANT {<权限1>, <权限2>, …} ON [owner.] <表名或视图名> TO {<用户名1>,<用户名2>, … | PUBLIC} [WITH GRANT OPTION]`
> - `<权限>` 指 `SELECT, DELETE` 等操作
> - 当有 `WITH GRANT OPTION` 时，被授权的用户还可以把获得的权限再授权给其他用户
> - 可以同时授权多个用户，如果用`public`则表示将权限授予所有数据库用户

### 权限回收
> [!NOTE] 语句格式
> `REVOKE {<权限1>, <权限2>, …} ON [Owner.] <表名或视图名> FROM {<用户名1>,<用户名2>, … | PUBLIC} [RESTRICT|CASCADE]`
> - `CASCADE`权限表示回收带有级联操作，即同时回收拥有 `WITH GRANT OPTION` 权限的用户授予出的用户权限
> - `RESTRICT`权限表示只有当用户没有将拥有的权限转授给他人时才能回收权限，否则系统将拒绝执行

## 嵌入式SQL


# 关系查询处理与查询优化
---
## 关系数据库系统的查询处理
### 查询处理过程
> [!NOTE] 查询过程
> 对查询语句进行扫描、词法分析和语法分析$\rightarrow$进行用户权限和完整性检查$\rightarrow$建立查询的内部表示(语法树)$\rightarrow$选择高效的查询处理策略用关系代数优化，进行代数优化$\rightarrow$生成查询计划

1. 解释方式：DBMS不保留可执行代码，每次重新执行查询语句，事务完成后返回结果。灵活应变性强，但效率较低，主要适用于不重复使用的偶然查询
2. 编译方式：先进行编译处理生成可执行代码，运行时直接执行可执行代码。执行效率高，系统开销小

### 执行查询操作的基本算法
#### 选择操作
1. 顺序扫描：按照元组物理顺序扫描每个元组，适用于被选中的元组占有较大比例或总元组数较小的关系。搜索代价为$B_{R}$
2. 二分查找法：物理文件按照选择字段有序排列。对于完全有序数据的搜索代价为$\lceil log_{2}B_{R}\rceil$
3. 索引(散列)扫描法：通过索引找到满足条件的元组指针，再通过指针检索满足查询条件的元组。适用于选择条件属性上有索引(B+,Hash等)
4. 复合选择(逻辑合取AND)：使用组合索引，使用单独索引(先找满足一个条件的元组指针，再判断这些元组是否满足另一个条件)，使用多个索引(分别检索满足两个条件的元组指针，然后合取交集)

#### 连接操作
1. 嵌套循环法：两组数据分别为内外循环直接连接，一般选用较少块的文件作为外循环的连接代价较小
2. 索引嵌套循环法：如果两个连接属性中的一个属性存在索引，可以适用索引扫描代替顺序扫描
3. 排序合并法：先按照搜索属性进行排序，依次搜索另一个表中具有相同属性的元组并连接，扫描到第一个不相同的元组就继续搜索源表的下一个元组。两个表都只需要搜索一次，尤其对于已经排序好的表大大减少连接时间
4. 散列连接法(Hash Join)：把连接属性作为Hash码，用同一个hash函数将两个表的元素散列到同一个hash文件中
   1. 划分阶段(partitioning phase)：对包含元素较少的表进行处理，将元组按hash函数分散到哈希表的桶中
   2. 连接阶段(join phase)：将另一个表经过hash函数散列到适当的桶中，并与与之匹配的元组连接起来

#### 投影操作
主要通过消除重复元组(如果投影属性列是主键则不用)，可以通过排序消除或者散列法(分到合适的桶，检查桶内是否有重复的元组)

#### 集合运算
并差交运算通常使用类似排序合并法，笛卡尔积运算通常使用嵌套循环法

## 关系数据库系统的查询优化
> [!TIPS] 由DBMS进行优化的好处
> 1. 优化器可以从数据字典中获取一系列用户无法获取的统计信息
> 2. 如果数据库物理信息发生改变，系统可以自动对查询重新优化选择合适的执行计划
> 3. 优化器能考虑更多种执行计划，并且包含了很多复杂优化技术

### 查询优化技术
1. 代数优化：通过改变代数表达式中操作的次序和组合，使查询执行更高效，不涉及底层存取路径
2. 存取路径优化：通过考虑数据的物理组织和访问路径，选取各种操作合适的存取路径
3. 代价估算优化：

## 代数优化


## 基于存储路径的优化


## 基于代价估算的优化