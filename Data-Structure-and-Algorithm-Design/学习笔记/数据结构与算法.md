`int swap(int &a, int &b)` 为C++中的引用概念，本质上仍是取外部变量的地址，对变量赋 `alias` 后引用外部变量值，但是函数过程中对参数的更改不影响外部变量的值，而直接引用变量指针函数内直接调用地址，对原数据的状态保留不友好
在C++中定义一个类之后，在类中可以定义 `public` 和 `private` 类型变量，其中 `public` 类型中可以直接进行外部访问，但注意当直接定义函数时，外部引用需要先使用 `<class> variable` 定义一个外部变量，再通过 `variable.function` 来调用类中的动态类型函数，或者应用 `class *variable = new class()` 后，再使用 `variable->function` 来调用函数；我们也可以在public中定义 `static int` 函数，这样在外部调用时就可以不用定义变量，直接使用 `class::function` 就可以调用函数
- 跳表：上图上代码 ![[Pasted image 20230920085754.png]]![[Pasted image 20230920090546.png]]
~~~Java
/* 如果存在 x, 返回 x 所在的节点， 
   否则返回 x 的后继节点 */  

find(x) {  
    p = top;  
    while (1) {  
        while (p->next->key < x) {
            p = p->next;  
		}
		if(p->next->key == x){
			return p->next;
		}
        else if (p->down == NULL) {
            return p->next;  
		}
		else 
        	p = p->down;  
    }
}  
~~~
- 遍历一个 `vector` 类型数组的几种方法，主要用到的是 `for (auto element : vector)`，其他具体方法可以看这篇帖子[C++中vector容器中元素输出（遍历）的5种方式](https://blog.csdn.net/weixin_74802373/article/details/130043838)
- 串的模式匹配算法：`KMP`算法
  基本想法是不移动原子串，移动要查找的模式串；定义一个 `next` 数组表示前后缀相同子串最长的长度
~~~C
int j = 0, k = -1;
next[0] = -1;
while (j < S.length)
{
	if (k == -1 || S[j] == S[k])
	{
		j++;
		k++;
		if (S[j] != S[k])
		{
			next[j] = k;
		}
		else
		{
			next[j] =0 next[k];	
		}
	}
	else
	{
		k = next[k];
	}
}
~~~
- 二叉树遍历方式转化：
  1. 后序遍历的最后一个字符一定是二叉树的根节点
  2. 根节点将中序遍历分成左右两子树
- 树相关知识点：
  1. 节点的度：节点拥有的子树数目，叶子结点的度为0
  2. 树的度：树中节点度的最大值

