本文涉及到的代码存放于[Programming-Methods-and-Practice/code · 郭忠滨/Road-To-CSAI](https://gitee.com/binisalegend/Road-To-CSAI/tree/master/Programming-Methods-and-Practice/code)
# 感受算法魅力
这章没有太多真正的算法，主要是灌输一些类算法的思想，例如二进制、栈思想、双指针等等
## *1. 猜数字看人品*
1. 解题思路：
   这道题感觉就是栈思想的初步展现吧，通过Tom回复或高或低，记录当前状态下可能正确值的最大和最小值。即不用记录下每个数据，只需要维护 `too low` 回复时的最大值，`too high` 回复时的最小值，当回复为 `right on` 时判断当前值是否位于最小最大值之间即可
2. 代码实现
   由于仅仅判断第二个单词 `high low on` 就能够判断回复，所以可以定义两个字符数组，仅使用 `strcmp` 函数比较第二个字符输入即可；同时，由于可能有多组游戏进行，在每组游戏结束后**一定要重置变量**；最后，题目要求输入0之后程序立刻终止，故 `scanf` 输入数字语句要放到循环末尾，避免输入0后程序依然等待Tom的回复
## *2. 摘桃子*
1. 解题思路 + 代码实现
   这题首先要明确的是对于每一天能摘下的桃子只有当天和前一天的，以及有多少棵树就需要计算到 树的数量+1 天才能够算出摘下桃子的总数；当天的桃子数在计算完当天能摘下的桃子数量之后直接更新成剩下的桃子数量，继续计算下一天能摘下的桃子数量即可
   具体思路方面，当时做的时候什么算法都不会就闷头疯狂分类讨论，具体如下：
   - Basic Case：分第一天的桃子是否能全部摘下，更新第一天的桃子数量为 `0` 或者 `b[0] - v` 
   - Recursion：分类讨论前一天剩下的桃子数量 `b[n-1]` 和今天的桃子数量 `b[n]` 相对于每天最多能摘下数量 `v` 之间的关系：
     - `b[n-1] < v && b[n] < v` ：分总计大于v或者总计小于v讨论
     - `b[n-1] >= v` ：当日能摘数直接为v，`b[n]` 不变（因为前一天剩下的已经烂了）
     - `b[n] >= v` ：当日能摘数直接为v，前一天还没摘完 `b[n]` 就不变（上一种情况），前一天摘完了就更新成 `b[n] + b[n-1] - v`
## *3. 达拉崩吧的酒宴*
1. 解题思路
   这题的思路我自己理解是先拿具体的数字来试，比如6、7这样的，然后在稍微大一点的数字试验时，可以发现最基本的思路就是两个中有一个有毒，另一个就是安全的。比如1-10，就可以1-4、3-6、5-8这样每两组()包括最后的9.10都有两个数的重合,就可以再加一组判断两个的，这样就可以联想到二进制的问题，即都转化为二进制，每一位为1的都由一只小白鼠试验；只要对应位数的小白鼠死了，就说明这只小白鼠对应的位数是1。这样，最终就是根据酒的桶数转化为二进制最大位数是多少，就需要几只小白鼠。划分依据即为log2
2. 代码实现
   有什么好实现的想明白log2就十行代码（bushi
## *4. 北湖挖坑*
1. 解题思路![[Pasted image 20230906233610.png]]
   - 这个本来我是直接用for循环遍历所有行的，就是如果碰到了高度高于当前行高度的说明被挡住了，但是这种做法时间复杂度直奔 O(n^2) ，可能优化一下能擦边过反正我是TLE
   - 于是打羽毛球之前求助了一波浩哥，在当时看感觉很神奇，现在看来这道题就是最一开始灌输栈的思想，也许是当时不会C++所以只能做简单的出入栈，好像如果用C++调那个 `deque` 直接秒了
     具体思路是：设置一个变量 `location` 用于存放某个位置的高度(注意是变量而不是数组即可)，首先将第一个位置高度赋给 `location` ，进入循环后读取每个位置的高度 `height`。如果该位置高度高于 `location` 存储的值（如1 2、3 4、6 7 8、10 11），则说明当前高度与存储高度差需要被填补，所需填补次数为 `height - location` ，并将当前的 `location` 更新为 `height` 的值；反之，说明当前湖面处于下陷状态（如2 3、4 5 6、8 9 10、11 12），这时就不需要被填补，只需要把当前的 `location` 更新为 `height` 即可。
2. 代码实现
   需要注意的点有：首先不能先当然直接开始循环，因为初始化的 `location` 和 `height` 都无法和输入数据的第一个变量相匹配，应该要在循环外先将变量初始化为第一块的高度；
   同时，在遍历完所有长度的高度后，还需要额外比较最后一块的高度，因为最后一块如果不是最大高度就始终需要被填补，因此最终需要填补的次数还要再加上 `MaxLength - height_last` 的值
## *5. 北湖深坑*
1. 解题思路
   这道题用到了双指针，相当于判定并记录两边的高度比较，如果有一个“凹下去的坑”就可以蓄水（我是真的看不明白NND）
   之所以不能从同一个方向遍历，是因为如果单方向一直下降，就会导致循环一直进行；而双指针则可以判定出某一个位置一定比最高点低，而当遍历到下一个高于最低点的时候就可以根据两者之间的高度差判断出蓄水量
2. 代码实现
   双指针实现代码（希望我未来的某一天能看懂吧）
~~~C
while (In < Out)
{
    deep = height[Out];
    while (height[In] >= height[Out] && In != Out)
    {
        if (height[Out] <= deep)
        {
            tot_store += deep - height[Out];
        }
        else
        {
            deep = height[Out];
        } 
        Out--;
    }

    deep = height[In] ;
    while (height[In] < height[Out] && In != Out)
    {
        if (height[In] <= deep)
        {
            tot_store += deep - height[In];
        }
        else
        {
            deep = height[In];
        } 
        In++;
    }
}
~~~
# 字符串处理、枚举
本章主要讲了一些遍历枚举，以及像 `strcpy strcmp strchr` 等字符串函数的应用
## *6. A+B(I)*
1. 解题思路
   最一开始的时候看到这道题确实没经验，想着都转化成十进制加完再换回来只处理对齐不就行了，最后写完直接收获TLE被浩哥提醒2的100000次方还是太过荒谬
   于是开始重写（），当然这道题思路对了以后对下面那道超级恶心的升级版有不小的帮助
   首先当然是从末尾开始加，每一位的所得值其实可以看作是当前位置上两数相加再加上前一位的进位，当然写上去肯定不是这么写，最终位数显示应该是上面所得结果取余2的结果，而保留下的进位则是结果整除2后的所得
   计算过程中还有一个需要注意的点是所给两个二进制数的首位均为1的情况，这样会最后比原来数多出一位，记得单独讨论
2. 代码实现
   - 这题开始就涉及到了很多字符串操作了，特别注意 `int` 和 `char` 类型混合输入时要及时用 `getchar()` 吃掉输入末尾的回车
   - 要引入一个通用变量 `carry_bit` 用来记录进位，这个变量可以从最后一位一直应用到结果位首，每一次遍历后的进位都用它记
   - 剩下没啥好说的，个人认为这题就是只要你别怕累敢写就行
## *7. A+B(II)*
1. 解题思路
   这题是我所写行数最多的一道题，没有之一
   题目主要的难点我认为有两点：小数点对齐和位数保留问题
   可能我还需要感谢自己当初不会一些高级的算法，直接建了4个数组分别存两个数的整数和小数部分：但一开始还是想得太简单了，认为 `scanf(%s.%s)` 就能帮我分开整数部分和小数部分（现在想起这不是纯痴心妄想凭什么.不会被当字符存进去），后来咨询chatGPT使用了 `strchr` 函数在字符串输入中搜索小数点，将小数点所在位置替换为结束符 `0` 然后分别 `strcpy` 到两个数组里，具体代码看下面
   计算过程思路相对简单，即从小数部分开始遍历，`carry_bit` 记录进位，具体加法实施参照上面那个简单的
   计算过程完成，接下来才是这道题恶心的小数点对齐和删除前导0问题。
   对于小数点对齐，我才去的策略是找到最长的那个整数长度（因为小数部分长度是固定的，不可能再比最长的小数部分长或者短了就），然后有数输数没数打空格
   但是实际操作发现其实结果并不一定是最长的那个整数部分，因为有可能加完前面有没用的前导0，这时我采取判断是否为无用0的策略，若是就替换为空格，这样结果字符数组的长度就一定是三个字符数组最长的那个，可以作为基准
   还要注意不能想当然都输出小数点（如果两个加数都是整数就没有，这个需要设置flag在输入时判断有没有小数点），以及注意保留小数点前紧挨着的那个0（如 `0.5` 不能输出成 `.5`）
2. 代码实现
   -  字符数组搜索（小数点）后分区保存代码
~~~C++
	char input1[10000];
    scanf("%s", input1);  // 读取整个输入字符串，包括小数点

    char *decimal_point1 = strchr(input1, '.');  // 查找小数点的位置

    if (decimal_point1 != NULL) 
    {
        *decimal_point1 = '\0';  // 将小数点替换为字符串结束符

        strcpy(number1_int, input1);  // 复制整数部分到number1_int
        strcpy(number1_fra, decimal_point1 + 1);  // 复制小数部分到number1_fra
    }
    else
    {
        strcpy(number1_int, input1);
        flag1 = 1;
    }
~~~
   - 判断是否为前导0并替换为空格代码
~~~C++
//删除结果里的垃圾0
    if (result_int[length_int_result-1] == '0')
    {
        for (int search = length_int_result - 1; search >= 0; search--)
        {
        //判断是否为0.5这种情况，就不能删除这个0
            if ((search == 0 && result_int[1] == ' ') || (result_int[0] == '0' && length_int_result == 1))
            {
                break;
            }
		//判断是前导0
            if (result_int[search] == '0' && result_int[search-1] == '0')
            {
                result_int[search] = ' ';
            }  
		//判断前导0结束
            else if (result_int[search] == '0' && result_int[search-1] != '0')
            {
                result_int[search] = ' ';
                break;
            }
        }
    }
~~~
## *8. 发言统计*
1. 解题思路
   这题就是学了二维数组动态内存分配（虽然后面都屈服直接建最大值了），再算的话就是 `strcmp` 比较字符相同了
2. 代码实现
   - 二维数组动态内存分配代码
~~~C++
// 使用动态内存分配来存储多个字符串
    char **loc = (char **)malloc(n * sizeof(char *));
    for (int i = 0; i < n; i++) 
    {
        loc[i] = (char *)malloc(10 * sizeof(char)); 
        scanf("%s", loc[i]);
    }
~~~
## *9. 解谜游戏*
1. 解题思路
   NND这个直接用上DFS（深度优先搜索，请看第五章），也不知道为什么要出在这，对我当时幼小的心灵造成了极大的创伤... 不过也算是从这道题开始我后面的题目都尽量将函数功能封装
  具体思路上，就是我们发现某一行亮着的灯完全可以由按它正下面的灯来熄灭掉，也就是只要我们确定了第一行的灯亮灭情况，后续的按键方法就已经确定了，只需要判断最后能不能将灯全部熄灭即可
  所以，我们可以开始封装功能函数了，首先是按下按钮状态变化函数 `change()` 和控制周边关联灯的亮灭情况的函数 `convert()`；接下来，我们需要一个转存函数 `Unload()`，用于在每次遍历中将全部密码锁情况转存到另一个数组中，避免因为一次遍历影响到后面的搜索；接下来是根据第一行按键情况遍历后面按键情况所需按键次数，并判断最后是否能使灯全部熄灭的函数 `TimCalculation` ，按下亮灯的下一行对应的灯，并最后判断最后一行是否还有亮着的灯即可（因为前面的灯一定都熄灭了）；最后是遍历第一行可能按键情况的DFS主函数 `FirstLineCondition` ，对于每一个灯都有按或不按两个选项（不按的选项可以通过按两次但是不加按键次数来替代情况），遍历完每个灯的两个情况再继续遍历下一个灯的情况，在遍历完第一行的所有灯之后进入 `TimCalculation` 函数开始计算和验证并更新最小按键次数
2. 代码实现
   1. 首先要注意在获取输入时每一行末都需要 `getchar()` 吃空格
   2. 在 `change()` 和 `convert()` 函数参数传递过程中因为 `change()` 需要通过指针来影响按键状态在全局中的变化，所以在 `convert()` 函数传递参数记得要用 `&square[row][column]` 来传入具体按键位置的地址，以及及时判断关联按键位置是否合法
## *10. 肥宅快乐串*
1. 解题思路
   这题的代码回头看去感觉写的依托答辩巨乱就，感觉其实思路并不难
   首先好像不能直接嵌套循环遍历所有字符搜索，时间复杂度太高了（虽然对于这道题只有一个用例过不去），于是参考讨论区大佬的思路换成每十个字符遍历一次，查看与fattyhappy的差异有几个字符，如果完全相同就直接换相同的字符；如果相差一个字符就在当前遍历字符左右（注意还有左哦！） 搜索有没有该位置上缺的那个字符；如果相差两个字符就直接看它俩换了是不是fattyhappy；有两个位置以上不相同就直接下一种
2. 代码实现
   相同的点是还是要记得每次遍历后验证要把字符转存到一个新数组里，防止因为一次的交换影响后续遍历（或者换完如果不符合条件再换回来）
   （这题真别看代码 太抽象了 我都不想仔细再看一遍）
# 贪心、排序
这章主要应用贪心算法，快排、归并排序等方法，因为我还是用C写的所以还学了 `qsort` 函数对结构、数组中某一元素进行排序的函数方法
## *11. 排兵布阵*
1. 解题思路
   这题感觉数学知识更多，首先是确定排队最终的纵坐标是所有纵坐标的中位数（我也不会解释，反正人家都说是中位数到一组数的距离之和最小）；对于横坐标我的理解过程是这样的，首先要找到一个类似基准点的东西，让所有横坐标都向这个基准点靠拢，并根据他们的横坐标排序来判断具体有多靠近这个基准点；这样我们就可以先按原本的横坐标进行排序，然后定义一个新的数组储存原本的坐标减去循环变量，这样相当于记下了每个变量相对于自己位置到目标点的距离，再对这个新的数组进行排序取中位数，最后算曼哈顿距离之和就好
2. 代码实现
   按结构变量中的某一元素进行排序的 `cmp` 函数
~~~C
//为qsort函数准备的排序函数
int cmpx( const void *a ,const void *b)  
{  
    return ((*(solider *)a)).x - ((*(solider *)b)).x;
}
~~~
## *12. 任务安排*
1. 解题思路
   这个题就是最经典的贪心问题，没有任何变式直接就是套公式
   具体算法就是先按结束时间进行从小到大排序，然后从头开始遍历，看下一个任务的开始时间是否在预存任务的结束时间之后，如果是则可完成任务数+1且预存任务更新为当前任务
2. 代码实现
   贪心算法基本代码示例
~~~C
	qsort(loc, n, sizeof(loc[0]), cmp);

    int second = 0, first = 0;
    for (second = 1; second < n; second++)
    {
        if (loc[second].start >= loc[first].end) 
        {
            count++;
            first = second;
        }
    }
~~~
## *13. 搬砖*
1. 解题思路
   这个题用到了归并排序，感觉跟二分搜索有类似之处：二分搜索是通过二分大小寻找一个符合条件的值，归并排序则是利用递归不断二分确定小部分的顺序排列最后进行合并
   归并排序的具体思路实现主要体现在归并排序主函数 `Mergesort()`，排序后合并数组函数 `Merge()`以及将排序后函数重新放到原数组的 `copy()` 函数。（我当时看了好多讲解都没看懂原理，感觉这个虽然是java代码但是讲的很清楚[图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园 (cnblogs.com)](https://www.cnblogs.com/chengxiao/p/6194356.html)）
2. 代码实现
   `Mergesort` 函数是归并思路的体现，具体来说就是完成了两步工作：分成两半+排完拼回来
~~~C
//分两半
	count += MergeSort(a, left, middle);
    count += MergeSort(a, middle + 1, right);
//拼起来
    count += Merge(a, loc, left, middle, right);
~~~
 `Merge` 函数则是完成了将两个排序好的数组拼起来的工作，具体来说可以理解成给两个数组分别设置一个指针，指针所在的数组元素较小的一方进入新数组，并且该数组指针向前移动，继续比较，注意要加上指针与临时数组位置的差值；如果另一个数组已经为空，就直接按顺序排入新数组即可；最后记得调用 `copy` 函数重置原数组
## *14. 水晶球*
1. 解题思路
  感觉这道题理清思路后代码还是相对比较好实现的 
  首先由于最后我i们要输出制作水晶球石头的编号，所以可以建立一个结构数组，直接在输入中储存这块石头的编号
  要明确的一点是，一块水晶能制作出水晶球的大小，取决于它三条边中最短的那条边，所以我们就很有必要在结构变量储存边长时直接把每块石头的三条边长短进行排序后再储存（如a最短边，b中等边，c最长边）因此我们在比较单个水晶石的时候，直接找出所有水晶石中，最短边大小最长的那块石头记录即可（可以结合在输入里直接维护最大值，少循环一次）
  而在比较合并后是否有更大的水晶，我们需要明确，只有当最长边与第二长边相同结合而成的水晶，才有可能使最短边变长进而扩大水晶球半径。因此，我们可以考虑先优先按最长边从大到小排序，再按第二长边，以此类推操作结束后，能合并且有效的水晶石就会相邻，只需要遍历一次即可。
  需要注意的是，合并以后之前的最短边有可能比第二长边长，所以要重新比较后再确定此时的水晶球半径，进而判断是否需要更新最大可制作半径
  **特别提醒！！一开始进行边长先排序再储存时一定要设置临时变量！！不然会导致后面排序的时候使用了已经排序过的变量**
2. 代码实现
   对结构元素进行优先级排序时的 `cmp` 函数
~~~C
int cmp(const void *a, const void *b)
{
    SideLen *c = (SideLen *)a;
    SideLen *d = (SideLen *)b;
    if (c->c != d->c)
    {
        return d->c - c->c;
    }
    else if (c->b != d->b)
    {
        return d->b - c->b;
    }
    else
    {
        return d->a - c->a;
    }
}
~~~
## *15. 卡牌游戏*
1. 解题思路
   以下以n=6举例，首先我们可以先分两种大情况：**1在手牌中**   **1在牌堆里**
	**1. 当1在手上时**：我们所期待的牌堆位置是234560，这样我们只需要n=6次即可将牌堆替换成期望的格式，那么此时我们只需要计算牌堆中在期待位置之后的牌的位置与期待位置的差值（因为如果一张牌在期待位置之前，它们会更早的到我们手牌中），并取它们中的最大值max_dis，在这个最大值max_dis所代表的操作次数后我们就可以保证所有的牌在我们需要使用它的时候都在我们手上，此时的总需要操作数即为 max_dis+n（如牌堆是003020，此时max_dis便是2与期待位置的差值4，所需次数为4+6=10）
	**2.当1不在手上时**：我们在这种情况下将561234视为我们的期待情况，此时我们可以再细分成两种情况，即1后的数字是否排成像1234这样的连续数字
	1. **如果1后面符合1234这样的排列**，我们则比较1前面的数字是否都在期待位置之前（注意是之前！因为仔细观察可以看出此时的期待数列并不能直接放牌，只有在期待位置之前才能在我们需要放这张牌的时候确保手里有）。如果**有任何一个数字在期待位置上或者之后**，就说明如果直接跟在后面放牌，至少有一张牌我们在需要时手里没有，所以我们就需要把1拿出来再重新开始放牌（因为1后面符合排列所以1后面的都能满足”需要时手里有“），此时所需次数为 1的位置 + n（如牌堆为046012，期待位置是345612，4在期待位置上，如果直接放3我们接下来手里没4，所以要把1拿出来才能开始，所需次数为5+6=11）；如果**所有的数字都在期待位置之前**，这样我们就可以直接放牌，所需次数就变成 n - 最后一个数（如牌堆为406012，期待位置是345612，直接放3每个数字都能顶出来，所需次数为6-2=4）。
	2. **如果1后面不符合1234这样的排列**，就直接表示我们不能在后面直接跟着放牌了，那么我们至少需要把1顶出来以后再放牌（即最小次数是 1的位置+n）。这时我们比较1后面的数是否在期待位置之后，如果**没有任何一个数在期待位置之后**，这样我们把1拿出来以后直接开始放1即可，后面所需都能顶出来，所需次数就是当前最小值 1的位置+n（如601304，期待位置是561234，把1拿出来直接放，所需次数为3+6=9）；如果**1后有数字在期待位置之后**，我们只需要计算牌堆中在期待位置之后的牌的位置与期待位置的差值，并取它们中的最大值max_dis，在这个最大值max_dis所代表的操作次数后我们就可以保证所有的牌在我们需要使用它的时候都在我们手上，此时的总需要操作数即为 max_dis+n+1的位置（如601002，最大差值为2到期待位置的距离2，所以需要次数为2+3+6=11）
2. 代码实现
   没啥好说的 别怕累
# 简单数据结构
这一章已经开始应用栈、队列的相关知识了，但是由于我还没有强迫自己用C++，所以这一章我在数据结构的使用上还是大部分使用了自建数组和头尾指针来进行数据结构的相关操作（像出入栈、进出队），也不知道未来还会不会再使用自建数据结构了，但是也做一个记录叭
## *16. 括号匹配*
1. 解题思路
   说起来好笑，这题原始思路竟然是我和舍友一起在华莱士店边炫边想出来的hhh
   一开始我们想的思路是把左右括号转换成1和-1，通过找加起来为0的就行。后来发现当然没这么简单，首先需要判断是否有根本没法匹配的字符串，一开始我以为只有 `)()(` 这样的，即第一和最后一个分别是右左括号，最后发现还可以这样 `()))(()` 也是无法匹配的.... 借鉴了一下大佬的思路解决了，即右括号只有在没有左括号的时候才会计数，如果有左括号存在就直接抵消，最后如果左右括号数均不为零就说明这个字符串匹配不了。这是我觉得这道题转化过程中最妙的一环（详见代码部分）
   同时我们可以建立两个数组，储存等效有n个括号的字符串有几个，这样就可以匹配直接计数了
2. 代码实现
   抵消储存括号机制代码
~~~C
for (long long t = 0; t < len; t++)
{
    if (loc[t] == '(')
    {
        left++;
    }
    else
    {
        if (left <= 0)
        {
            right++;
        }
        else
        {
            left--;
        }
    }
}
if ((left != 0) && (right != 0))
{
    continue;
}
~~~
## *17. 看楼房*
1. 解题思路
   一开始以为这个和前面的[[#*4. 北湖挖坑*]]很像，做起来发现受到颜色判断的影响差距还是很大的
   有一个需要注意的点是，一开始本来想用 `hashset` 哈希函数来判断某个颜色是否出现过的，但是后来运行过程中发现有可能出现的情况是某一种颜色出现了两次但是只有一次被挡住了，但是这个颜色依然存在，所以就不能简单地通过 `true false` 来判断颜色了
   于是换个思路，用一个数组 `hashset[color]` 来记录一种颜色对应出现的次数每次循环都加一，再单独设置一个变量 `count` ，只要出现一种没出现过的颜色就加一，然后判断是否挡住了前面的楼房，如果被挡住了对应颜色的楼房数量就减一；这时再判断该颜色是否为0，如果为0说明这种颜色彻底没了，`count--`，并且去掉被挡住的楼房（出栈，用 `stacksize--` 来实现）；最后让该遍历楼房入栈，记录下当前位置能看到的颜色 `count` 数量
2. 代码实现
   自定义栈结构和出入栈操作示例代码
~~~C
for (int i = 0; i < n; i++)
{
    //判断颜色是不是重复的
    if (hashSet[building[i].color] == 0)
    {
        count++;
    }

    hashSet[building[i].color] += 1;
    //看不见的楼房出栈
    while (StackSize > 0 && Stacks[StackSize - 1].height < building[i].height)
    {
        if (hashSet[Stacks[StackSize - 1].color] > 0)
        {
            hashSet[Stacks[StackSize - 1].color] -= 1;
            if (hashSet[Stacks[StackSize - 1].color] == 0)
            {
                count--;
            }
        }
        StackSize -= 1;
    }

    Stacks[StackSize].color = building[i].color;
    Stacks[StackSize].height = building[i].height;

    color_nums[i] = count;
    StackSize++;
}
~~~
## *18. 填坑 I*
1. 解题思路
   这题大半夜写的，看了一个佬的思路直接秒了两道（向无名大佬致敬）
   总体思路就是，计算每个位置的高度与最高值差值取余2的值（`(max - height[i]) % 2`），如果当前所得值与前一个位置所得值相同，就直接让前一个位置出栈，相当于两个相邻的是一样的高度（或者能用１Ｘ２石头补齐），如果最后栈空或者栈长为1就说明一定可以填平
2. 代码实现
   这个学到了一个读取到文件终止条件 `while (scanf("%lld"， &n) != EOF)` 就可以读取到文件终止啦，现在还只有在乐学特定题目中有用
   还是基本的出入栈自定义指针操作，可以用栈长来替代
## *19. 填坑 II*
1. 解题思路
   看完佬思路秒掉的第二题，再次感谢佬（bushi
   这个几乎可以直接照搬上面那道题的代码来做简单改动，这次题目限制了只能水平放了，所以代码情况中需要加上一些限制条件：首先基本思路上是这次我们就不能通过取余的方式来判断能否填平了（因为没法竖着放补上高度），所以就要直接比高度，高度相同才能出栈；其次，不能有“凹下去”的位置，即如果满足当前高度与前一块高度相同，还要继续判断再前面一块是否比当前高度低，如果低就直接不可能填平；最后，这次最后不能只简单判定栈长为1就可以了，必须要剩下的那块是最高高度才可以（这样才可以补周边的，如果不是最高的就没法填平）
2. 代码实现
   就注意一下可以边输入边维护最大值叭（）
## *20. 选举*
1. 解题思路
   这题感觉是最荒谬的一题...一开始做完了没觉得有问题就是有两个过不了，自己把用例扒出来加了两个特例过了，最后发现是题目表述有问题直接改题了....感觉改完题就有点没意思，我也懒得改代码了，就直接按照原思路记记叭
   首先对本族最有利的投票方式当然是投给离自己最近且还没投票的异族人，这样既可以票出去一个人还可以让对面少一票。于是想到了记录每一个种族有多少票，即一开始统计一共有多少个冬马族和雪菜族人，在有一族人死完之前一直循环投票，如果输入是D族人：则先判定X族是否有票数，如果X有票说明它早就应该死了活不到现在，直接族人数量减一，X族的票数减一；如果X没有票说明D成功活下来了，入栈且D族票数加一。以此类推
2. 代码实现
   在具体代码实现方案上还有许多细节，首先要建立两个储存族人顺序的数组 `race[] loc[]` ，即在第一次遍历中入栈的族人进入到另一个数组中，这样就可以重新保存第二轮的投票顺序，再第二轮投票开始之前清空原数组，改为从另一个数组向原数组转存活下来的族人，以此类推，但是每一族剩下的票数是可以一直留存的
# 查找、搜索
从这章开始逼自己用C++写了，所以可能会调用 `map deque queue vector` 这些C++标准库
这章主要是讲BFS（广度优先搜索）、DFS（深度优先搜索）、
## *21. 成语接龙*
1. 解题思路
   基本思路就是应用队列进出，如果第一个字符和上一个字符相同，并且该字符未被使用过，前一个字符出队，新字符入队；当搜索到结束成语时返回
2. 代码实现
   感觉这道题思路并不难，只是代码具体实现上需要用到不少之前没用过的语法，需要注意的点如下：
   - `queue <变量类型> 队列名` 可以直接建立一个队列，不需要再设置头尾指针进行出入队操作，只需要访问C++库函数如 `.front() .push() .pop() .empty()` 等
   - 应用 `scanf` 可以使用 `%*d` 来忽略一个变量的输入
   - `map <key, value>` 是一个key与值一一对应的结构变量，在本题中由于只需要记录成语的头尾字符，所以可以用第一个字符作为key值一一对应到该成语的结尾字符，具体绑定代码为 `<map变量名>[key].push_back(value)` 
   - `auto i: <变量名>` 相当于令i在后续变量值中进行搜索，如搜索map类型变量所有key值为...的绑定值
## *22. 地下城与勇士*
1. 解题思路
   首先建立二维数组存储所有位置的情况，随后应用bfs光度搜索。还是借助队列，当队列不为空时设置变量等于队首，出队，判断其朝四个方向分别移动一步的情况，是否超出边界或者撞墙；如果遇到怪兽，应用 `time % k == 0` 判断怪物在当前时间是否存在。如果符合要求则入队，继续循环。需要注意的点是，由于怪物仅在k时间会消失且每一秒都必须前进，所以可能需要走“回头路”，故不能简单判断某一位置是否走过
2. 代码实现
   - 首先对于迷宫前进问题，可以建立向两方向前进的数组分别为 `dx[4] = {1, -1, 0, 0}; dy[4] = {0, 0, 1, -1}` ，这样就可以使用循环遍历朝四个方向前进的情况，步数 + 1
   - 本题在应用 bool 类型变量判断一个位置是否经过时需要建立三维数组，采用这种方式即 `already[x][y][time % k] == true` ，这样就可以包含走回头路等怪兽消失的情况，也能包含初始点 S 之后也可以走的情况
   - 由于每秒都必须走，所以可以直接用time来替代走过的步数
## *23. 带旋转的数独游戏*
1. 解题思路
   这题主打一个一开始一点不会，一点思路都没有那种...
   首先既然需要判断共16个4X4的小数独的旋转情况，就可以先判断小数独四条边的情况，通过旋转次数和四条边在旋转后的相对位置，应用dfs来判断16X16数独每条边是否符合要求，同时可以给4X4小数独进行编号，通过编号也可以推断出小数独的位置，从而进行最后的旋转方式输出
2. 代码实现
   这题主要是代码的实现问题，需要推断不同变量之间的关系，具体如下：
   1. 将A-F转化为10-16，这样在判断最后的边是否符合要求时就可以直接通过边长总和是否为120来判断
   2. 通过16X16数组中数据的相对位置和4X4数组位置，推算出每个小数组四条边长的计算公式，如`Part_Map[i][j][1] = Map[4*i-3][4*j-3] + Map[4*i-3][4*j-2] + Map[4*i-3][4*j-1] + Map[4*i-3][4*j];`
   3. 对16个4X4数组进行1-16编号，这样可以通过编号判断出该小数独在第几行第几列
   4. 应用dfs算法遍历16个小数独的旋转方式（转0-3次），累加记录当行数值之和，如果一行遍历结束后符合该行数值和等于120则清空记录数值，开始记录下一行
   5. 遍历完全部小数独以后，调用check函数判断列是否符合要求，这时需要根据旋转次数判断位于同一列上的数是之前定义的小数独的哪一条边，检验其和是否为120，若满足条件则更新此时所需的最小的旋转次数和小数独的旋转情况
   6. 最后在输出每个数独的具体旋转次数时可以通过遍历每个小数独之前dfs后的旋转次数来输出， 即 `while(FinalTurn_cnt[i][j]--)` 输出一次当前小数独所在的行列
## *24. 绳子切割*
1. 解题思路
   这题比较抽象的地方是它不告诉你要多长的绳子问你最多有几根，而是告诉要几根绳子问最长是多长，最终看讨论区找到思路用二分搜索
   具体思路大概是先找到一个中间长度，判断这个长度的绳子能不能剪出所要求的长度，能就继续搜索更长的一半，不能就搜索长度更短的一半
2. 代码实现
   - 首先要考虑一下干脆没法剪的情况，即绳子总长也小于要求的根数
   - 之后就是二分搜索模板代就完了，循环遍历一直搜 ，记得考虑一下边界
## *25. 进圈*
1. 解题思路
   这个题跟[[#*22. 地下城与勇士*]]思路很像，就是记录每个位置的信息，通过建立队列出入队，向四个方向移动的数组遍历可能的移动情况。不同的是，这道题没有怪兽（bushi）但是可以在一秒之内在同一个方向移动k步，所以也需要遍历在一个方向上走了几步，并判断是否走过、撞墙或者超出边界
2. 代码实现
   - 由于输出的是最短需要时间，所以可以建立一个结构存放到达每个位置所需要的时间，每遍历一次行走时间+1，而同一方向的步数可以走最多k步
   - 剩下就是同样的bfs, `queue` 建立队列，符合条件入队，遍历所有的情况直到队空就行，模仿一下[[#*22. 地下城与勇士*]]就行
# 动态规划
这章主要就是动态规划相关的内容，其实感觉总结之前并不是太能理解，很多都是参考其他大佬的思路写完也是云里雾里，总体来说好像是找到状态转移方程，并且用内存换时间，相较于递归时间较快，因为每运行一次都会记录下生成的数据，在之后的遍历过程中就可以直接使用而不是再进行一次遍历了
**！！注意注意！！一定记得 `dp[i][j]` 中是有 `i` 个物品可供选择，背包最大承重为 `j`，而不是第 `i` 个物品！！切记！！**
## *26. 篮球练习*
1. 解题思路
   首先这道题感觉最容易想到的一定是递归，我一开始也是这么做的，本地运行没有问题，但是乐学上会TLE，没办法既然是在动态规划的专题那确实需要用动态规划做，于是乎开改。
   思路其实大体相同，就是能走到某一个点的方案数，是能走到它上面和左面点的方案数之和，如果这两个点中有小黑子防守的点则不算，一直搜索到要走的终点即可
   一开始使用递归做的时候我想的是如果在递归过程中遇到防守点位，就直接不算他；但是后来发现这种方式在我计算最上面一行和最左面一行会很难办，因为如果从起点到某个位置出现防守点，之前均有一种到法，出现以后就不可能到这个点。咨询了王总之后发现可以直接将防守点设置为0，初始化起点为1，然后一视同仁加就完了，这样就很好地解决了首行首列的问题
2. 代码实现
   - 只需要注意在应用bool数组判断某个点是否为防守位置时要先判断在不在范围内，如果不在会导致无效内存引用
   - 同时，因为最后像 “20 20 19 19” 这样输入得出的路径数并不小，所以输出最终结果的数组记得要开 `long long`
## *27. 方向标*
1. 解题思路
   这题也是弄了很久都没搞懂，拖了好几天才问别人差不多搞明白了
   大体思路就是，对于每一个箭头所在的位置，都可以先判断一下其相对于上一行左点和右点的位置：如果在左点之左或是右点之右（例如上一行是 2 6，当前箭头在1 或 7这样的）就只有一种摆放方式（即6->1 或 2 ->7），所以对于当前行的起始点的方案数量就要加上上一行的方案数（即 `dp[i][left/right] += dp[i-1][j]`）；而如果箭头的位置在上一行左右点之间（如上一行 2 6，当前行为4），那么以上一行的左右点为起始点就都可以（即 2->4, 6->4），所以就要左右两端点的方案数量都加上上一行的方案数量。最后遍历最顶端一行；所有位置的方案数量即可
2. 代码实现
   不知道放啥，自己看代码叭
## *28. 考试*
1. 解题思路
   这个就是最标准的背包问题，我一开始不理解的是我想使用贪心算法，就是我把题目价值按从大到小排序，优先做价值高的题目做，如果时间还在要求之内就继续按价值搜索题目做。但是最后发现只能过三分之二的用例，看书以后发现好像是贪心算法最后可能会剩下位置，而剩下的位置利用价值远低于本来可以应用的价值，所以导致无法保证是最优解
   所以，没办法了，我开始学背包问题该咋做：
	- 大概思路还是遍历，先初始化第一道试题，小于第一道试题所需时间的所给时间放不下，所以得分为0，大于第一套题所需时间的总时间得分就赋成第一道题的分数
	- 然后循环开始，比较总时间和一道题所需时间，所给时间在0到较小值的情况分数不会增加，直接与做上一个数量的题的分数一致；对于时间大于等于做题所需时间小于总时间的情况，则比较做上一个数量题的分数和减去本题所需时间情况下做上一个数量题的分数加上本题分数的大小，取其较大值
	- 感觉要说服自己的一点是，要为有N道题目、时间为T的所有情况均赋值，记录他们所得分数的情况
2. 代码实现
   因为这道题是标准的背包问题，直接放代码，大部分背包问题都需要开二维数组记录某一情况下的结果值，为后续的遍历保留结果
~~~C++
long long CalculateMaxScore(int que_num, int total_time)
{
    int jMax = min(question[0].time-1, total_time);
    for (int i = 0; i <= jMax; i++)
    {
        score_rem[1][i] = 0;
    }
    for (int i = question[0].time; i <= total_time; i++)
    {
        score_rem[1][i] = question[0].score;
    }

    for (int i = 1; i < que_num; i++)
    {
        jMax = min(question[i].time-1, total_time);
        for (int j = 0; j <= jMax; j++)
        {
            score_rem[i+1][j] = score_rem[i][j];
        }
        for (int j = question[i].time; j <= total_time; j++)
        {
	        score_rem[i+1][j] = max(score_rem[i][j], score_rem[i][j-question[i].time] + question[i].score);
        }
    }
    return score_rem[que_num][total_time];
}
~~~
## *29. 一道简单的背包题*
1. 解题思路
   这题一开始始终没弄明白如何表示能“恰好”放入背包，后来和大佬交流了一下其实就可以当作是普通的背包问题，特殊的点只在取余单位背包大小所得相同的物品其实可以看作是一种情况（举例来说，如果 V = 5，那么对于8和13两种情况来说其实是等同的，因为想要恰好装下都需要取余 V 结果为2的物品大小来填补），所以就可以直接记录取余之后的值，并判断当前背包容量情况下的取法情况；而 `MethodCount[i][j] = MethodCount[i-1][j]` 语句则相当于记录背包问题中不取新增物品的情况，并在最后与取新增物品的情况数相加得到当前背包体积下所涵盖的情况
2. 代码实现
  取余背包问题代码
~~~C++
long long CalculateTotalMethods(int n, int V)
{
    MethodCount[0][0] = 1;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < V; j++)
        {
            MethodCount[i][j] = MethodCount[i-1][j];
        }
        for (int j = 0; j < V; j++)
        {
            int k = (j + p[i] % V) % V;
            MethodCount[i][k] = (MethodCount[i-1][j] + MethodCount[i][k]) % MAX;
        }
    }
    return MethodCount[n][0] - 1;
}
~~~
## *30. 有一个人前来买瓜*
1. 解题思路
   这题感觉也很抽象，大概是因为我还是不太明白背包问题的整体思路叭... 看到讨论区里有大佬说是相当于背包问题加了个条件，试一下（）
   首先先遍历所有的瓜数量 `i` ，再从0开始遍历所有可能给出的最大瓜总重量 `j`， 然后从500开始向下遍历所有可能给出的成熟度最小值 `k`，分别判断当前可获得价值是否大于等于0（初始化记得均为-1）和遍历当前重量加上新增瓜重量是否小于最大值，则当前遍历下的最大价值即为 `max(dp[j][k] + g[i], dp[j+w[i]][min(k+v[i], 500)])`，个人感觉这一步就跟标准背包问题那个比较不加这个物品和加了这个物品剩余容量存之前的物品数加起来的价值哪个大有异曲同工之处
2. 代码实现
   - 这题理论上来看是一个三维的背包问题，但是建立三维数组分别存三个变量和最大买瓜价值会TLE，所以只能用二维数组 `dp[weight][maturity] = value` 来分别对应三个值，最后通过遍历符合条件的所有 `dp[][]` 来确定最大可能获得价值
   - 个人感觉代码里 `min(k+v[i], 500)` 其实就是给出过要求成熟度的最大值为500，所以如果成熟度比500都大就没有意义了，相当于肯定能符合这个要求，所以直接按500算找最大值就行
   - 感觉一开始我建立结构存四个变量的想法应该也能实现，但是最后参考的建三个数组 `w[i] v[i] q[i]` 相对调用更为简便
   - 最后的遍历求最大可获得价值感觉有点绕，代码放下再来梳理一下叭
~~~C++
long long ResultOutput(int w, int v)
{
    long long result = -1;
    for (int i = 0; i <= w; i++)
    {
        for (int j = v; j <= 500; j++)
        {
            result = max(result, dp[i][j]);
        }
    }
    return result;
}
~~~
通过最后多次输入给出的实际最大总重和最小总成熟度，遍历所有总重小于要求和成熟度大于要求组合情况，比较他们所得最大价值并输出最大的 `result` 

# 结语
写到这里，大二上半学期小学期程序设计方法与实践的课程记录就结束啦。回首望去，三周全部工作就是坐在电脑前思考每节课后的题目，倒也不失是一种新的感受。
也许未来的很长一段时间，我都很难再会面对这种纯粹的生活，但是每天与电脑上奇奇怪怪的代码打交道，一定会是我也许数年后的主旋律叭...
再近一点，也希望这一篇记录，能为我今年后续数据结构与算法设计课程打下一点基础，这也是我使用Obsidian记录真正迈入计算机领域的第一篇完结文章，特此记录其打开了我未来CSAI学习之路的大门

**<big>记于2023.9.10</big>**
