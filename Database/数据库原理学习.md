# 数据库系统引论
---
## 数据库系统结构
### 数据库系统的三级模式结构
1. Schema(逻辑模式)：应用DDL语言(Database Description Language)，全体数据逻辑结构和特征的描述，构成了数据库的总体框架
2. External Schema(Subschema)：外模式是用户能看见的局部数据的逻辑结构和特征，是与某一应用具体相关的数据逻辑表示；不同用户有不同的外模式，保障数据安全性；介于模式与应用之间
3. Interal Schema(内模式)：存储模式，一个数据库只能有一个，是整个数据库实际存储的表示
![](Pasted%20image%2020240228090112.png)
### 三级模式结构的二级映像
- 数据库系统的三级模式是对数据的三个抽象级别：**视图级、概念级和物理级**，它使用户能逻辑地抽象地处理数据，而不必关心数据在计算机内部的存储方式，把数据的具体组织交给DBMS管理
- 外模式与模式之间的映像定义局部数据逻辑结构与全局逻辑结构的对应关系，实现了数据的**逻辑独立性**：一个模式对应多个外模式。当模式结构改变，则只要修改外模式与模式间的对应关系，而不必修改外 模式中的局部逻辑结构，因而相应的应用程序亦可不必修改
- 模式与内模式之间的映像定义全局数据逻辑结构和物理数据存储的对应关系，提供了数据的**物理独立性**：一个模式对应一个内模式。当数据库的物理存储结构改变时，仅需要修改模式与内模式间的映像关系，而可以使模式保持不变，从而使应用程序保持不变

## 数据库管理系统

### 数据库管理系统的功能

#### 定义功能
1. 模式定义语言(DDL)：定义数据库全局逻辑结构，定义记录型和记录的数据项信息，说明数据之间的联系
2. 外模式定义语言：定义用户的局部逻辑结构，形式功能与DDL基本相同
3. 内模式定义语言：定义物理数据库的结构，包括数据的存储方式、存取方式和检索技术、以及对数据的分区分页

#### 操作功能
数据操纵语言(Data Manipulation Language, DML)实现对数据库的**插入、删除、修改、查询**操作

#### 保护功能
安全性、完整性控制、并发控制和恢复

## 数据库系统的不同视图
数据库的相关人员主要分为四类：**数据库管理员（DBA）、系统分析员、应用程序员和用户**

不同人员涉及数据的抽象级别不同，因而具有不同的数据库视图![](Pasted%20image%2020240228104620.png)
1. 数据库管理员（DBA）：决定数据库中的信息内容和结构、存储结构和存取策略、监控运行安全性以及数据库的改进重组
2. 系统分析员：负责应用系统的需求分析和规范说明，与用户和DBA协商确定硬软件配置，参与数据库的概要设计
3. 数据库设计人员：确定数据，调查用户分析，设计数据库各层模式
4. 应用程序员：设计编写应用系统模块，进行调试安装
5. 用户：偶然、简单和复杂用户

# 数据模型
---
数据模型是数据特征的抽象，用来描述数据的一组概念和定义，包含**数据结构、数据操作和数据的完整性约束**三部分

1. 数据结构：描述数据库组成对象以及对象之间的联系，通常按照数据结构的类型命名数据模型，描述系统静态特性
2. 数据操作：对数据库中各种对象实例允许执行的操作，描述系统动态特性
3. 数据的完整性约束：保证数据的正确、有效和相容

## E-R(Entity-Relationship)概念模型
### 概念定义
1. 实体(Entity)：客观存在并且相互区别的事物，可以是具体对象或抽象概念；具有同类特征的实体集合称为实体集
2. 属性(Attribute)：实体特征称为属性，实体可由若干个属性来刻画；属性分为“类型”和“值”：类型即属性名，属性值的集合构成了一个学生实体
3. 联系(Relationship)：实体之间的联系(不同实体集的联系)，事物内部的联系(实体内部属性之间的联系)；有一一(1: 1)对应、一对多(1: n)和多对多(m: n)等

### E-R图
1. 实体用矩形框表示，属性用椭圆形表示
2. 实体之间的联系用菱形框表示，连线旁标明实体间联系的类型

### 联系
1. 基数比约束：即上文提到的一一(1: 1)对应、一对多(1: n)和多对多(m: n)等
2. 参与约束：一个实体集中的所有实体都参与联系称为完全参与，否则称为部分参与
3. 实体参与度：实体参与联系的最小和最大次数，称为实体的参与度
4. 弱实体：依赖其他实体存在的实体，E-R图中用双框矩形表示，表示全部参与时与菱形用双线连接
5. 子类实体：将一个实体集根据个体的不同特性分为多个子集（有点像Java的子类那种）

### 优势
1. 用户需求不变的情况下，模型稳定
2. 能够方便的转化为具体的DBMS所支持的数据模型

## 层次模型
> [!NOTE] 定义
> 用树型结构表示各类实体以及实体间的联系
> 1. 有且只有一个节点且没有双亲结点(根节点)
> 2. 根节点以外的其他节点有且只有一个双亲结点

### 优势
1. 数据结构简单清晰
2. 查询效率较高
3. 提供了良好的数据完整性支持

### 缺陷
1. 不能直接表示两个以上实体型之间的复杂联系以及实体型之间的多对多联系
2. 对数据插入和删除操作限制过多
3. 查询子女节点必须通过双亲结点

## 网状模型
两个或两个以上的节点都可以有多个双亲结点，有向树变成了有向图

### 优点
1. 一个节点有多个双亲的特性更加符合现实世界的关系规则
2. 具有良好的性能，存取效率高

### 缺陷
1. 结构复杂，且随数据量增加复杂程度不断上升，不利于最终用户掌握
2. DDL和DML语言复杂，且访问数据时必须自己选择路径，程序编写有负担

## 关系模型

### 基本概念
基本数据结构被限制为二维表，一个二维表称为一个关系
1. 关系：
   1. 关系(relation)：一个关系可用来表述一个实体集，是一张由行列组成的二维表
   2. 属性(attribute)：每一列为关系的一个属性
   3. 域(domain)：一个属性对应一个值的集合，即域是属性的取值范围，如学号的域为10位数字的集合
   4. 元组(tuple)：关系是元组的集合，一个元组对应实体集的一个个体，可以理解为一条数据
   5. 键(key)：键是由一个或多个属性组成等，能够唯一识别一个元组

2. 关系模式(relation schema)
   1. 关系名(属性1，属性2，$\cdots$，属性n)
   2. **关系数据库模式**是一组关系的集合，这组关系模式对应的关系集合称为关系数据库
   3. 关系模型中基本的数据结构是单一的关系
   4. 关系必须是规范化的，最基本条件即为关系的每一个分量必须是一个不可再分的原子数据项

3. 数据完整性约束
   - 实体完整性、参照完整性、用户自定义完整性

4. 数据操纵
   1. 对数据的查询、插入、删除和修改操作；可以进行多种运算，运算结果又构成新的关系
   2. 关系运算分为关系代数和关系演算

### 关系模型的优势
1. 数据结构简单
2. 一体化数据子语言
3. 数据独立性搞
4. 面向集合的存取方式
5. 坚实的理论基础
6. 有利于开展其他应用


# 关系数据库
---
> [!NOTE] 定义
> 支持关系模型的数据库系统
> 
> 由数据结构、数据操作和完整性约束构成

## 关系模型的基本概念

### 关系的定义
1. 域(domain)：一组具有相同数据类型值的集合，表示属性的取值范围，如$D_{2}=\{male, female\}$，$D_{2}$为域名
2. 笛卡尔积(Cartesian Product)：给定一组集合$\{D_{1},D_{2},\cdots,D_{n}\}$，则集合的笛卡尔积表示为：$$D_1\times D_2\times...\times D_n=\{(d_1,d_2,...,d_n)\mid d_i\in D_i,i=1,2,...,n\}$$表示的是域中所有取值的组合(不能重复)
3. 元组(tuple)：笛卡尔积中每一个元素$(d_{1},d_{2},\cdots,d_{n})$叫做一个$n$元组，简单理解就是任意一种组合
4. 分量(Component)：笛卡尔积元素$(d_{1},d_{2},\cdots,d_{n})$中每一个$d_{i}$叫做一个分量，简单理解就是元组中的一个变量

#### 关系
> [!NOTE] 定义
> $D_1\times D_2\times...\times D_n$的任一个子集称为$\{D_{1},D_{2},\cdots,D_{n}\}$上的一个关系。$N$叫做关系的目或度(degree)

关系中的每一行对应一个元组，通常用$t$表示；每一列对应一个域，关系中的列称为属性，每一列用属性名表示。其中$t[A_{i}]$表示元组$t$在属性$A_{i}$上的值

从笛卡尔积中取出实际有意义的元组构造关系

 严格来说，关系是一种规范化后的二维表中的集合，为了使相应的操作简化对关系加入了限制：例如限定有限数据，为关系每列添加属性以取消有序性等

#### 规范化关系性质
1. 列的同质性(Homogeneous)：每一列中的分量是同一类型的数据，来自同一个域
2. 不同的列可以出自同一个域：不同的属性必须有不同的属性名
3. 行、列的顺序无关
4. 关系中不能出现重复的元组
5. 分量必须取原子值

### 关系模式和关系数据库
- 关系的型称为关系模式(relation schema)，是对关系的描述，一般简记为关系名和属性名的集合
- 关系是值，是元组的集合
- 关系模式的集合称为关系数据库模式，是对数据库中所有数据逻辑结构的描述
- 关系数据库模式中的每个关系模式上的关系的集合称为关系数据库

### 键
> [!NOTE] 定义
> 为区分不同元组，能够唯一标识元组的属性或属性组成为关系的键
> 
> - 其中能够起表示作用的键称为候选键
> - 若有多个候选键，则选一个键作为主键(primary key)
> - 关系键由多个属性组成称为联合键
> - 关系中的所有属性构成关系的键，称为全键

### 完整性约束
1. 实体完整性约束(Entity Integrity Constraint)
   1. 主键的值不能为空或部分为空
   2. 元组键为空将导致元组不可标识，不能表示任何实体，没有意义
2. 参照完整性约束(Reference Integrity Constraint)
   1. 是对关系中作为外键的值的约束

## 关系代数
> [!NOTE] 定义
> 抽象的查询语言，用对关系的运算来表达查询
> 
> 三要素：运算对象、运算结果、运算符

- 运算符分类：
  1. 传统的集合运算：并、差、交、广义笛卡尔积
  2. 专门的关系运算：选择、投影、连接、除，涉及行列运算，是专门为数据库应用而引进的特殊运算

### 传统集合运算
$R$ 和 $S$具有相同的目$n$(即两个关系都具有$n$个属性)，且相应的属性取自同一个域

#### 并运算(Union)
- $R\cup S$仍为$n$目关系，由属于$R$或属于$S$的元组构成，即$$R\cup S=\{t\in  R\vee t\in S\}$$
#### 差运算(Difference)
- $R\cup S$仍为$n$目关系，由属于$R$而不属于$S$的元组构成，即$$R-S=\{t~|~t\in  R\wedge t\notin S\}$$

#### 交运算(Intersection)
- $R\cup S$仍为$n$目关系，由既属于$R$也属于$S$的元组构成，即$$R\cap S=\{t\in  R\wedge t\in S\}$$
- 交运算也可以用差运算来表示，即$R\cap S=R-(R-S)$

#### 笛卡尔积
- $R$中所有元组与$S$中所有元组的拼接，即$$R\times S=\{\widehat{t_\mathrm{r}t_\mathrm{s}}\mid t_\mathrm{r}\in{R}\wedge t_\mathrm{s}\in{S}\}$$![](Pasted%20image%2020240302223122.png)

### 专门关系运算
#### 选择(Selection)
- 从关系中选择满足一定条件的元组子集$$\sigma_{{F}}({R})=\{t\mid t\in{R}\wedge t({F})\}$$其中$F$是限定条件的布尔表达式，由逻辑算符连接比较表达式组成
- 从行的角度进行运算，选择在关系$R$中使$t(F)$为真的所有元组

#### 投影(Projection)
- 模式$R$上的投影运算表示为$$\prod_x({R}){=}\{{t}[{X}]\mid{t}{\in}{R}\}$$其中$\prod$是投影算符，$X$是模式$R$属性的子集，$t[X]$表示$R$中元组在属性集$X$上的值，或为元组$t$在$X$上的投影
- 从列的角度进行运算，从$R$中选出若干属性列组成新的关系

#### (内)连接(Join)
##### 条件连接($\theta$连接)
> [!NOTE] 定义
> 将两个关系中满足$\theta$条件的元组拼接起来形成新元组的集合
>  设属性$A$和$B$分别是关系$R$和$S$上的属性，且定义在同一个域上，$R$和$S$的连接记为：$$R \bowtie_{A\theta B}S~\{\mathrm{t}\mid t=\overset{{\frown}}{{t_r}{t_s}},\mathrm{t_r}\in\mathrm{R}\wedge\mathrm{t_s}\in\mathrm{S}\wedge\mathrm{t_r}[\mathrm{A}]~\mathrm{\theta}~\mathrm{t_s}[\mathrm{B}]\}$$其中，$\bowtie$是连接符，$A\theta B$是连接条件，$\theta$是比较符


- 即从两关系的笛卡尔积中选取两者关系满足连接条件的元组
- 最常用的连接是两个属性值相等的比较，称为等值连接，即$\theta$为$=$

##### 自然连接
> [!NOTE] 定义
> 一种特殊的等值连接，要求两关系中进行比较的分量必须是**相同的属性组**，并且在结果中把重复的属性列去掉
> $$R\bowtie S=\{t~|~t=\overset\frown{t_{r}t_{s}}[\bar{A}],~ t_{r}\in R\wedge t_{s}\in S\wedge t_{r}[A] = t_{s}[A]\}$$

如下图所示，去掉了相同的$R.B$和$S.B$列并合并为$B$列![](Pasted%20image%2020240303182832.png)

#### 除(Division)
> [!NOTE] 定义
> 进行除法运算$\div$，要求两关系有定义在同一域上的属性或属性组；$R\div S$的结果生成一个新关系$R^{\prime}$，$R^{\prime}$的属性是$R$的属性中去掉与$S$具有公共域属性的其他属性
> j
> 设$R(X,Y),~S(Y),~R^{\prime}(X)$，则$R\div S$记为：$$R\div S=R^{\prime}=\{t~|~t\in R^{\prime} \wedge t_{r}\in R \wedge t_{s}\in S\wedge t_{r}[R^{\prime}]=t\wedge t\bowtie S\subseteq R\}$$

如下图，即筛选出$R$中所有$B、C$ 两列全部符合$S$的$A$属性 ![](Pasted%20image%2020240303185815.png)

### 扩充的关系运算
#### 属性重命名
> [!NOTE] 定义
> $$r^{\prime}({R}^{\prime})={\delta}A{\rightarrow}{B}(r)$$其中$A$表示模式$R$中的原属性，$B$表示重命名后的属性，$r$是模式$R$中的一个关系

- 重命名运算可以同时对一组属性进行操作
- 通过重命名运算，可以
  1. 在同一个关系上做自然连接运算
  2. 做同一个关系的笛卡尔积
  3. 将两关系的等值连接方便的表示为自然连接

#### 外连接(Outer join)
> [!NOTE] 定义
> 对自然连接的拓展，连接结果中除了满足连接条件的元组外还包含没有被连接的元组

- 左外连接：连接结果包含了关系$R$(左边关系)中不满足连接条件的元组，这些元组对应关系$S$属性上的值为空值，记为$R\bowtie_{L}S$![](Pasted%20image%2020240303195819.png)
- 右外连接：连接结果包含了关系$S$(右边关系)中不满足连接条件的元组，这些元组对应关系$R$属性上的值为空值，记为$R\bowtie_{R}S$
- 完全外连接：连接结果同时包含了关系$R$(左边关系)和关系$S$(右边关系)中不满足连接条件的元组。即连接结果是左外连接和右外连接的并，记为$R\bowtie_{F}S$

# 关系数据库标准语言SQL
---
## SQL的简介
> [!SUMMARY] 定义
> SQL语言是一种介于关系代数与关系演算之间的语言，是通用、功能极强的关系数据库语言

- SQL的特点：
  1. 综合统一：集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)的功能于一体，能完成数据库生命周期中的全部活动；同时实体间的联系都用关系表示，操作符单一，每种操作只使用一种操作符
  2. 高度非过程化：只需指出“做什么”，无需了解存储路径，提高数据独立性
  3. 面向集合的操作方式：查询、插入、删除和修改操作面向的对象都是集合
  4. 以同一种语法结构提供多种使用方式，不同方式下的语法结构基本一致

## SQL的系统结构
- SQL中的关系模式称为基本表(Table)，基本表的集合构成数据库的模式，对应三级模式结构的模式
- 基本表在物理上与存储文件相对应，所有存储文件的集合为物理数据库
- 外模式（由试图(View)组成）
![](Pasted%20image%2020240317190007.png)
## SQL的数据定义
> [!NOTE] 主要内容
> SQL的数据定义主要包括定义表、定义视图和定义索引，在SQL2中还增加了对数据库模式的定义![](Pasted%20image%2020240317190435.png)

### 模式的定义和删除
- SQL模式由**模式名、权限标识符和模式中元素的描述符**组成
  1. 权限标识符指明拥有该模式的用户或账号
  2. 模式元素包含一个数据库应用的表、视图和索引等
#### 模式定义
- 在定义模式时先给出模式名和权限标识符：`CREATE SCHEMA <模式名> AUTHIRUZATION <用户名>`
- 也可以在模式定义中进行创建表、视图和定义授权等操作
#### 模式删除
- 删除模式语句：`DROP SCHEMA <模式名> [CASCADE | RESTRICT]
  - `CASCADE`(级联式)方式：在删除模式的同时把该模式中的对象全部一起删除
  - `RESTRICT`(限制式)方式：如果该模式已经定义了下属的数据库对象，则拒绝该删除语句的执行

### 基本表的定义、删除与修改
#### 定义基本表
> [!NOTE] 基本语法
> `CREATE TABLE <table name> (<row name> <data type> [列级完整性约束条件] [表级完整性约束条件])`

1. 表名：所定义的基本表名字
2. 列名：组成该表的各个属性(列)
3. 完整性约束条件：
   - 列级完整性约束条件：涉及相应属性列的完整性约束条件
   - 表级完整性约束条件：涉及一个或多个属性列的完整性约束条件
   - 语法为 `constraint <约束名> <约束>`

- 通过 `create table <模式名>.<表名> (...)` 语句格式可以在定义表的同时指定所属的数据库模式名

#### 修改基本表
> [!NOTE] 基本语法
> `ALTER TABLE <table name> [ADD <row name> <data type> [完整性约束]] [DROP <row name> [CASCADE | RESTRICT]] [ALTER <row name> <data type>]`

- `DROP`子句用于删除指定的列名，`RESTRICT`表示必须没有视图和约束引用时才能删除该列
- `ALTER`子句用来修改列的定义，如修改列的数据类型、宽度等

#### 删除基本表
> [!NOTE] 基本语法
> `DROP TABLE <table name> [RESTRICT | CASCADE]`

- 默认约束参数为`RESTRICT`，即不能被其他表参数所引用（如`check`，`foreign key`等）

### 索引的建立与删除
建立索引是加快数据查询速度的有效手段
#### 建立索引
> [!NOTE] 语句格式
> `CREATE [UNIQUE] [CLUSTER] INDEX <index name> ON <table name> (<row name> [<次序>])`

- 索引名可以建立在数据表的一列或多列上，各列名之间用逗号分隔
- `<次序>`指定索引值的排列顺序，其中`ASC`表示升序，`DESC`表示降序，默认参数为`ASC`
- `UNIQUE`表明此索引的每一个索引值只对应唯一的数据记录，对于已经含有重复值的属性列不能建立，同时插入新纪录时DBMS也会自动检测新纪录在该列上是否取了重复值
- `CLUSTER`表示要建立的索引是聚簇索引
  1. 非聚簇索引：数据存储在一个位置，索引存储在另一个位置，索引带有指针指向数据的存储位置
  2. 聚簇索引：对表的物理数据按列进行排序，即索引与数据是一体的，叶节点存储的就是本身的数据
  - 聚簇索引直接确定表中数据的物理顺序，因此一个表中只能有一个聚簇索引；适用于很少对基表进行增删，同时对经常要搜索范围值的列尤其有效
  
#### 删除索引
> [!NOTE] 基本语法
> `DROP INDEX <index name>`

### 索引选择
1. 对某个属性使用索引能极大提高对属性上值的检索效率
2. 但带索引的表占用空间更大，维护索引和对数据进行操作会花费更长时间

- 建立索引：查询操作相比于更新操作更多的属性，经常查询`where`子句中常量进行比较的属性，频繁出现在连接条件中的属性
- 不建立索引：更新操作比较频繁

## SQL的数据操纵
### 数据查询
> [!NOTE] 语句格式
> `SELECT [ALL | DISTINCT] <目标列表达式>`
> 	   `FROM <表名或视图名>`
> 	   `[WHERE <条件表达式>]`
> 	   `[GROUP BY <列名1> [HAVING <条件表达式>]]`
> 	   `[ORDER BY <列名2> [ASC | DESC]]`

- `SELECT`：指定要查询的属性列
- `FROM`：指定查询对象（基本表、视图）
- `WHERE`：指定查询条件
- `GROUP BY`：对查询结果按照指定列经`HAVING`语句筛选后的值进行分组，该属性列值相等的元组为一个组
- `ORDER BY`：对查询结果表按指定列值进行升降序排列

#### 单表查询
- 应用列别名`select <row name> as <bios name>`改变查询结果的列标题
- 使用`DISTINCT`短语消除查询结果中取值重复的行，要注意作用范围是所有目标列，因此不对每一列使用而对整个命令使用

##### WHERE子句常用的查询条件
![](Pasted%20image%2020240318110926.png)
值得注意的是字符串匹配操作中`EACAPE`操作：`WHERE Cname LIKE 'DB\_%i__’ ESCAPE '\'`

##### 使用集函数
如`count, max, min, avg, sum`等，应用类似`SELECT COUNT(DISTINCT Sno) FROM SC`等语句进行计数和求解相关值操作

##### 对查询结果分组
> [!TIPS] 基本语法
> 1. 使用`WHERE`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderhist WHERE productid = 2 GROUP BY productid`
> 
> 2. 使用`HAVING`进行选择：`SELECT productid, SUM(quantity) AS total_quantity FROM orderlist GROUP BY productid HAVING SUM(quantity)>=30`

- `WHERE`和`HAVING`语句的区别
  1. 作用对象：`WHERE`作用于基表或视图，选取满足条件的元组；`HAVING`作用于组，选择满徐条件的组；可以从与`GROUP BY`的位置关系理解
  2. `WHERE`语句不能使用聚集函数，`HAVING`可以

#### 连接查询
1. 自然连接：等值连接的一种特殊形式，会自动删去重复的行 `SELECT buyer_name, sales.buyer_id, qty FROM buyers, sales WHERE buyers.buyer_id = sales.buyer_id`
2. 自身连接：由于连接的双方完全是同一个表，因此必须起别名加以区分
3. 外连接：相较于内连接的区别在于同时将主体表中不满足连接条件的关系一并输出 `SELECT Student.Sno, Cno FROM Student LEFT JOIN SC ON (Student.Sno = SC.Sno)`，也会输出Sno并不对应的Student表中的关系

#### 嵌套查询
> [!NOTE] 定义
> 将一个查询块嵌套在另一个查询块的`WHERE`子句或`HAVING`短语的条件中的查询称为嵌套查询
> 
> - 子查询不能使用 `ORDER BY` 子句

- 不相关子查询：嵌套查询从里向外进行，即将子查询运算的结果作为父查询的条件
- 相关子查询：取外层查询中表的第一个元组，若内层查询返回结果为`TRUE`则将元组放入结果表

##### 子查询的谓词
1. 带有`IN`谓词的子查询(不相关子查询)：`SELECT <row name> FROM <table name> IN (SELECT <row name> FROM <table name> WHERE ...)`
2. 带有比较运算符的子查询：**子查询一定在比较符之后**，比较特殊的是`<>`等价于`!=`
3. 带有`ANY`或`ALL`谓词的子查询：
   - `ANY`：任意一个值；`ALL`：所有值
   - 跟在比较运算符后面用，类似于 $\exists$ 和 $\forall$
   - 有些时候可以用集函数替代，如 `< ANY` 等价于 `< MAX`，一般用集函数效率更高，能减少比较次数


# 关系查询处理与查询优化
---
