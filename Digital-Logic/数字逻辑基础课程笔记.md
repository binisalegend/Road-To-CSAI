# 概述
---
## 模拟信号与数字信号
> [!NOTE] 对比
> - 模拟信号(Analog)：连续，时间，数值
> - 数字信号(Digital)：离散且变化，是某个最小量的整数倍

- 模拟电路与数字电路应用接口电路进行信号转换(ADC和DAC)

### 数字电路的特点
1. 采用二进制，易实现，易复制
2. 抗干扰能力强，精度高
3. 可编程性强，集成度高
4. 便于长期存储，使用方便
5. 保密性好

## 数字信号的表示方法

1. 二值逻辑：只有两种对立逻辑状态的逻辑关系，0和1表示逻辑关系而不是数值
2. 逻辑电平：表示逻辑1和逻辑0的电平，如TTL、CMOS等![](Pasted%20image%2020240303232144.png)
3. 波形图(waveform)：用波形图形直观表示0和1
   - 时序图(timing diagram)：将输入信号和输出信号的关系按照时间顺序排列得到的波形图

## 数字电路的基本功能及其应用
- 典型电子信息系统组成框图![](Pasted%20image%2020240303234512.png)

# 数制与编码
---
## 数制
> [!NOTE] 基本要素
> 基数(符号)和位权(规则)
> 1. 基数：数制中每一位数所用到的数码的个数
> 2. 位权：数制中每一固定位置对应的单位值代表的值

| 数制   | 简称               |
| ---- | ---------------- |
| 二进制  | Binary，$B$       |
| 八进制  | Ocral，$O(Q)$     |
| 十进制  | Decimal，$D$      |
| 十六进制 | Hexadecmical，$H$ |

## 二进制符号数的表示方法
### 原码表示
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数为该数绝对值的二进制
> 
> $n$位数字采用原码表示的数据范围$-(2^{n-1}-1)\sim(2^{n-1}-1)$

### 反码表示
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数：正数用原码表示，负数用反码表示
> 
> $n$位数字采用反码表示的数据范围$-(2^{n-1}-1)\sim(2^{n-1}-1)$

### 补码(complement)
> [!NOTE] 定义
> 设数$N$是包含$n$位整数、$m$位小数的二进制数，则$N$的补码表示为$$(N)_{补n}=2^{n}-N$$
> 补码与$N$的大小有关，与整数位数$n$有关，但与小数位数$m$无关

- 求补码的常用方法：
  1. 将原码补足$n$位整数后**整体**求反加1
  2. 将数$N$补足$n$位整数，令从右向左的第一个1及其右边的0不变，其余各位求反

### 补码表示法
> [!NOTE] 表示方法
> 首位二进制数表示符号(0正1负)，后$n-1$位数：正数用原码表示，负数用该数绝对值的补码表示
> 
> $n$位数字采用反码表示的数据范围$-(2^{n-1})\sim(2^{n-1}-1)$

### 求有符号数的相反数
1. 原码表示法：将符号位取反，其余位不变
2. 反码表示法：将整个数值连同符号位一起取反(求反码)
3. 补码表示法：将整个数值连同符号位一起取反加一(求补码)

### 扩展数据的宽度
1. 原码表示法：在符号位与数据位之间填充0
2. 反码和补码表示法：直接进行符号扩展，即正数前面直接补足位的0，负数补1

### 补码表示符号数的加减运算
- 只需要加法器就可以完成加减运算，可以节省硬件节约成本；是符号位直接参与运算，结果仍为补码表示

## 十进制表示的二进制编码——BCD码(Binary Coded Decimal)
- 逻辑相邻：只有一位不同的两组编码
### 自然码(8421BCD)
感觉啥也没变，就是二进制编码

### 5421BCD
- 第一位自反，其他位上下对应![](Pasted%20image%2020240306152705.png)

### 2421BCD
- 直接沿轴自反(4-5之间)

### 余3码
- 前五位=8421码+3，其余各位沿轴自反

### 余3循环码
- 首位与余3码相同，后面位数分别与前一位做异或运算

> [!IMPORTANT] 加法规则
> 两个BCD码相加结果必须还是BCD码；如果相加出的BCD码不合法，应将本位加`0110(10的补码)`，并向高位进位

## 格雷码(gray)
1. 逻辑相邻：相邻两个编码中只有一位不同，其他各位均相同

- 位置相邻的格雷码逻辑相邻
- 最高位自反，其余各位关于中心轴对称![](Pasted%20image%2020240306154415.png)

### 二进制码与格雷码进行转换
- 异或运算：$A\oplus B$
> [!NOTE] 转换方式
> 二进制码转换格雷码：$$G_{n-1}=B_{n-1},~G_{i}=B_{i+1}\oplus B_{i}$$![](Pasted%20image%2020240306154448.png)
> 格雷码转化二进制码：$$B_{n-1}=G_{n-1},~B_{i}=B_{i+1}\oplus G_{i}$$![](Pasted%20image%2020240306154457.png)

# 逻辑代数基础
---
逻辑运算的表示方法：名称、真值表、逻辑表达式、逻辑符号和波形图等

## 逻辑变量和逻辑函数
- 逻辑：事物因果之间遵循的规律，如“与”、“或”、“非”等
- 逻辑变量：逻辑代数中的**二值**变量，取值只有“0”和“1”两个值，代表成对出现的逻辑概念

### 逻辑变量
#### “与”逻辑关系
> [!NOTE] 定义
> 当决定事件的各个条件全部具备之后，事件才会发生，表示为逻辑乘法：$$\mathrm{Y=A\wedge B=A\&B=A\cap B=A\cdot B=AB}$$

- “与”门：![](Pasted%20image%2020240506133317.png)

#### “或”逻辑关系
> [!NOTE] 定义
> 当决定事件的各个条件中有一个或一个以上具备之后，事件就会发生，表示为逻辑加法：$$Y=A\cup B=A\vee B = A|B=A+B$$

- “或”门：![](Pasted%20image%2020240506133731.png)

#### “非”逻辑关系
> [!NOTE] 定义
> 决定事件的条件只有一个，当条件具备时，事件不会发生；条件不存在时，事件发生。表示为逻辑取反：$$Y=\bar A$$

- “非”门：![](Pasted%20image%2020240506133944.png)


- 波形图（以“与”运算为例，$F=A\cdot B$）：![](Pasted%20image%2020240506134142.png)

- 逻辑运算的五种表达方式：**名称**、**真值表**、**逻辑表达式**、**逻辑符号**、**波形图**

### 逻辑函数
> [!NOTE] 定义
> 把“与”、“或”、“非”三种基本逻辑运算结合成逻辑表达式，并将逻辑表达式结果赋予另外一个逻辑变量$$F=A\cdot\bar{B}+\overline{C\cdot D}$$记为$F=(A,B,C,D)$

- 任何形式的逻辑函数，只要各自的真值表相同则彼此相等
- **任何**一个逻辑行为都可以用一个逻辑函数来表述

一个逻辑函数对应了一张真值表，一张真值表对应了一个(若若干个)逻辑函数

## 逻辑代数的基本运算规律

| 名称                | 公式1                                            | 公式2                                            | 类别        |
| ----------------- | ---------------------------------------------- | ---------------------------------------------- | --------- |
| 0-1律              | $A\cdot0=0$                                    | $A+1=1$                                        | 常量和变量间的等式 |
| 自等律               | $A\cdot1=A$                                    | $A+0=A$                                        | 常量和变量间的等式 |
| 自补律               | $A\cdot\bar A=0$                               | $A+\bar A=1$                                   | 常量和变量间的等式 |
| 分配律               | $\mathrm{A\cdot(B+C)=A\cdot B+A\cdot C}$       | $\mathrm{A+B\cdot C=(A+B)(A+C)}$               |           |
| 重叠律               | $A\cdot A=A$                                   | $A+A=A$                                        | 逻辑函数特有    |
| 反演律(德$\cdot$摩根定理) | $\overline{A\cdot B}=\overline{A}+\overline B$ | $\overline{A+B}=\overline{A}\cdot\overline{B}$ | 逻辑函数特有    |

- 逻辑函数中没有指数和系数，没有加法和减法

- 反函数：两个逻辑函数$F$和$G$的输入变量相同，且$F$和$G$对任意一组相同的输入都有相反的函数值，记作$F=\overline G$

### 逻辑代数运算的三个重要规则
1. **代入**规则：任何一个逻辑等式将等式两边出现的同一个逻辑变量都代之以同样的逻辑函数，逻辑等式仍然成立。
2. **反演**规则：对于任意逻辑函数$F$，做以下三种变化后可以得到$F$的反函数$\overline F$：
   1. 把原表达式中的$\cdot$和$+$运算符调换
   2. 把原表达式中的常量0和1调换
   3. 把原表达式中所有原变量换成反变量，反变量换成原变量
   - 需要注意的是，**不能打乱原式的运算顺序**，同时**不属于单变量上的“非”号应保留不变**
3. **对偶**规则：如果两个逻辑函数相等，则它们的对偶函数也相等。求对偶函数的方法如下：
   1. 把原表达式中的$\cdot$和$+$运算符调换
   2. 把原表达式中的常量0和1调换
   3. 原表达式中的原变量和反变量均保持不变
   - **逻辑代数基本运算规律的表格中，公式2是公式1的对偶式**

### 逻辑代数基本定理
#### 合并定理
$$AB+A\overline{B}=A，(A+B)(A+\overline{B})=A$$

#### 吸收定理
$$A+AB=A，A(A+B)=A，A+\overline AB=A+B，A(\overline A+B)=AB$$

#### 添加项定理
$$\begin{aligned}&AB+\overline{A}C+BC=AB+\overline{A}C&(A+B)(\overline{A}+C)(B+C)=(A+B)(\overline{A}+C)\\&AB+\overline{A}C+BCD=AB+\overline{A}C&(A+B)(\overline{A}+C)(B+C+D)=(A+B)(\overline{A}+C)\end{aligned}$$

### 其他
$$\overline{AB+\overline{A}C}=A\overline{B}+\overline{A}~\overline{C}\hspace{0.5cm}\overline{(A+B)(\overline{A}+C)}=(A+\overline{B})(\overline{A}+\overline{C})$$

### 复合运算和符合逻辑门
#### 复合运算
1. “与非”门：$F=\overline{A\cdot B}$![](Pasted%20image%2020240507154415.png)
2. “或非”门：$F=\overline{A+B}$![](Pasted%20image%2020240507154451.png)
3. “与或非”门：$F=\overline{A\cdot B+C\cdot D}$![](Pasted%20image%2020240507154554.png)
4. “异或”门：$F=A\oplus B=A\overline B+\overline AB$![](Pasted%20image%2020240507155237.png)
   1. 多变量“异或”运算取决于变量中取值为1的变量个数：为奇数则异或结果为1，为偶数则异或结果为0
   2. 异或函数中任意一个输入变量取反，运算结果取反
   3. 等式两边的逻辑变量可以互相交换位置而仍然保持等式的成立
5. “同或”门：$F=A\odot B=AB+\overline{A}\overline{B}$![](Pasted%20image%2020240507155657.png)
   1. 多变量“同或”运算取决于变量中取值为0的变量个数：为偶数则异或结果为1，为奇数则异或结果为0
   2. 同或函数中任意一个输入变量取反，运算结果取反
   3. 等式两边的逻辑变量可以互相交换位置而仍然保持等式的成立

#### 逻辑运算符号的完备性
- “与”、“或”、“非”是一组逻辑功能完备的逻辑运算符；“与或”、“或非”、“与或非”运算各自都是功能完备的逻辑运算符

## 逻辑函数的两种标准形式
### 最大项和最小项
- 首先这个部分可以参考一下离散数学的相关章节[离散数学](离散数学.md)(要吐了，好像清git搞没了...)

1. 最小项：$n$个变量的积，其中每个变量都以原变量或反变量的形式出现且仅出现一次
   1. 对于任意一个最小项，只有一组变量使它的值为1
   2. 任意两个不同的最小项乘积(相“与”)恒为0
   3. 全体最小项之和(相“或”)恒为1
2. 最大项：$n$个变量的和，其中每个变量都以原变量或反变量的形式出现且仅出现一次
   1. 对于任意一个最大项，只有一组变量使它的值为0
   2. 任意两个不同的最大项的和(相“或”)恒为1
   3. 全体最大项之积(相“与”)恒为0

#### 最大项与最小项之间的关系
变量数相同，编号相同的最小项和最大项之间存在互补关系，即$$\overline{m_i^n}=M_i^n\text{或}\overline{M_i^n}=m_i^n$$

### 标准表达式1：最小项之和式(标准“与或”式)
> [!NOTE] 定义
> 由若干个最小项相“加”（相“或”）而构成，也叫标准“与或”式

- 任意一个逻辑函数表达式都可以被展开成唯一的最小项之和式，记作$\sum\limits m(1,\cdots,2^n)$,

### 标准表达式2：最大项之积式
> [!NOTE] 定义
> 由若干个最大项相“乘”（相“与”）而构成，也叫标准“或与”式

- 任何一个逻辑函数表达式都可以被展开成唯一的最大项之积式，记作$\prod M(1,\cdots,2^{n})$ 

## 逻辑函数的代数化简法
- 简化逻辑函数能节省门电路，减少输入端数量，同时提高电路稳定性

- 最简“与或”表达式应该满足如下两条件：
  1. 表达式中乘积项个数应该是最少的
  2. 每一个乘积项中所含的变量应该是最少的

> [!NOTE] 定义
> 反复运用基本公式和常用公式消去多余项和多余因子，以求得最简表达式

1. 并项法：利用合并定理$AB+A\overline B=A$和互补律$A+\overline A=1$将两项合并成一项，同时消去一个因子
2. 消项法：利用吸收定理$A+AB=A$和添加项定理$AB+\overline AC+BCD=AB+\overline AC$消去多余的项
3. 消元法：利用吸收定理$A+\overline AB=A+B$消去多余的项
4. 配项法：利用添加项定理和互补、重叠律，在逻辑表达式中先添项，再消项

- 对于“或与”表达式，先利用**对偶式**将表达式转换为“与或”式，化简后再转回去![](Pasted%20image%2020240508001636.png)

## 逻辑函数的卡诺图化简法
- 逻辑相邻最小项：任意两个变量个数相同的最小项，如果组成它们的各个变量（原变量或反变量）中，只有一个变量互补（互反）而其余变量均相同（同为原变量或反变量）时，就称这两个最小项是逻辑相邻的最小项。

- 两个逻辑相邻最小项相“或”，会产生一个“与”项并同时消掉一个变量

### 卡诺图的特点
1. $n$变量的卡诺图有$2^n$个方格，每个方格表示一个最小项
2. 变量按行列分为行列两组，每组变量取值按格雷码排列
3. 卡诺图任一行或一列的两端上的小方格所代表的最小项在逻辑上是相邻的

- 逻辑函数为最小项之和：将表达式中所有最小项对应的方格都填“1”，其余小方格都填“0”
- 逻辑函数为最大项之积：将卡诺图上编号与表达式中最大项编号相同的小方格里都填写“0”，而其余的小方格里都填写“1”
- 逻辑函数为一般“与或”式：将“与或”式中所有“与”项在卡诺图中所覆盖的区域内的所有小方格都填“1”（已经填过“1”的小格除外），其余都填“0”
- 逻辑函数为一般“或与”式：将“或与”式中所有“或”项在卡诺图中所覆盖的区域内的所有小方格都填“0”（已经填过“0”的小格除外），其余都填“1”

### 最小项合并规律
- 在卡诺图上把两个相邻的小格圈起来，相当于把这两个小格所代表的逻辑相邻最小项合并(相“或”)，从而生成一个“与”项并消去一个互补变量

> [!IMPORTANT] 卡诺图圈最小覆盖原则
> 1. 每一个“1”都必须被卡诺圈覆盖，至少被圈一次
> 2. 卡诺圈在满足上一个条件情况下应尽可能少
> 3. 每个卡诺圈应包含尽可能多的“1”，但必须是$2^i$个
> 4. 每个卡诺圈都必须至少有一个独属于自己的“1”

### 求最简“或与”式：
  1. 圈“0”求$\overline F$的最简“与或”式，对$\overline F$进行反演运算就能得到$F$的最简“或与”式![](Pasted%20image%2020240508013554.png)
  2. 直接圈“0”写“或”项得到函数$F$的最简“或与”式![](Pasted%20image%2020240508013604.png)

### 多输出逻辑函数的卡诺图化简法
- 利用各函数间的公共项，达到整体化简的目的![](Pasted%20image%2020240508013845.png)

## 非完全描述逻辑函数
- 完全描述逻辑函数：对输入变量的每一组取值都有确定的函数值F（“1”或“0”）与之对应
- 非完全描述逻辑函数：逻辑函数不是被完全定义的，对于某些组变量的取值，函数有确定的取值与之对应；而对于另外其他组变量的取值，函数没有确定的取值与之对应

- 任意项(无关项)：使函数值为任意值（仅限于“0”和“1”）的变量取值所对应的最小项，用小写希腊字母$\varphi$或$d_i$表示，与无关项对应的函数值用“x”或“d”表示；若用最大项之积表示，最大无关项用大写$\phi$和$D_i$表示

### 使用卡诺图化简非完全描述逻辑函数
- 尽可能使逻辑相邻最小项数量最大化![](Pasted%20image%2020240508014801.png)

## 逻辑函数的描述
What can I say？![](Pasted%20image%2020240508014038.png)![](Pasted%20image%2020240508014050.png)

# 组合逻辑电路
---
- 由逻辑门组成，内部无反馈环节，不具有“记忆”功能，输出仅由当前时刻的输入决定
## 组合逻辑电路的分析
> [!NOTE] 分析一般步骤
> $\text{电路}\rightarrow\text{逻辑式(化简)}\rightarrow\text{真值表}\rightarrow\text{逻辑功能}$

### 加法器
#### 半加器
> [!NOTE] 构成
> 由5个逻辑门组成的2输入、2输出逻辑电路，其中$S$是本位值，$C$是进位 $$S=A\oplus B,~C=AB$$![](Pasted%20image%2020240508144208.png)

- 半加器只能考虑上一位的进位，其逻辑符号如图所示：![](Pasted%20image%2020240508145438.png)

#### 全加器
> [!NOTE] 构成
> 由12个逻辑门组成的3输入，2输出组合逻辑电路。
> 
> 其中$A_{i},B_{i}$为本位加法输入，$C_{i-1}$为上一位进位；输出$S_{i}$为本位值，$C_{i}$为进位值

- 全加器的逻辑符号如图：![](Pasted%20image%2020240508151123.png)

#### 四位全加器
![](Pasted%20image%2020240508151859.png)

- 四位全加器的输入与输出之间的关系为：$$S_3S_2S_1S_0=A_3A_2A_1A_0+B_3B_2B_1B_0+CI$$
### 数据选择器


## 组合逻辑电路的设计



## 组合逻辑电路中的竞争和冒险



## 组合电路的系统应用



# 触发器
---
## 触发器的结构和工作原理



## 触发器的工作特性



## 触发器的逻辑功能及相互转换



## 触发器应用举例



# 时序逻辑电路
---
- 由**组合逻辑电路**和**存储电路**构成，在某一时刻的输出状态不仅与该时刻输入状态有关，还与**原来的输出状态**有关
- 存储电路的输出反馈到组合电路的输入端
- 
1. 输出方程：
## 时序逻辑电路的分析方法



## 常用中规模时序逻辑电路及其应用



## 时序逻辑电路的设计



## 综合应用