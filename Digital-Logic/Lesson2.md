## 八进制转换为十六进制

以**二进制**为桥梁

## 十进制转换二进制

整数除二取余数（除到0），从后往前排
![[Pasted image 20240229203950.png]]小数乘二结果减一 ， 若不为0则为1 否则为0
## ![[Pasted image 20240229204318.png]]给定精度的小数位数确定

由精度确定要保留到的位数


## ![[Pasted image 20240229204739.png]]常用的数字

## ![[Pasted image 20240229204935.png]]原码  反码 补码

- 源码：第一位表示符号，**0**为正，**1**为负
- 反码：**符号位**依旧放在最高位 正数用原码 负数用反码
- 补码：设**N**为一二进制数（不谈小数位数）整数n位，小数m位
		其补码N<sub>补</sub> =  2^n -N
		或者补足n位（在前面加 **0** ）后求反加一 **注意：** 是在小数（如果有）位的最后一位
		方法三：
		![[Pasted image 20240229210207.png]]
## Another Ques
	![[Pasted image 20240229210438.png]]
	![[Pasted image 20240229210459.png]]
## 补码实现二进制的加减法

**使用补码可以使得加法器实现减法的效果** ， 简单来说，若要求 ***A-B*** 可视为 ***A + (-B)*** 即使用A的补码加上-B的补码，可得到结果的补码 such as:
![[Pasted image 20240229211105.png]]

## 溢出判断

**溢出** ：当补码计算后超出原来位数表示的最大值 ， 就会造成溢出
![[Pasted image 20240229211606.png]]


## BCD码 

用二进制来表示十进制码的一种编码

由于四位二进制有16个 ， 要表示的数只有 10个 ，因此会有不同的表达方式（据老师说要全记住）：
![[Pasted image 20240229212346.png]]

**有一些规律**

***有权码****： 如 8421 5421 四位数字就对应了四位二进制数的权重 
		例如5421BCD中的5 == 5+0+0+0 即**1000** 
***无权码*** ：顾名思义，不能直观看出 ，仍然有投机取巧的办法
		其中 ：**余3码** == **8421码** + 3 （显然易见）
		 余3循环码的定义依赖于**格雷码**（格雷码是相邻两位之间仅差1，怎么获得这个码呢，就是对原来的数的基础上相邻两位之间进行比较，如果两位之间不同，则得1，相同则得0，比较从右向左进行）
		 仍然有投机取巧的办法：
		 ![[Pasted image 20240229213144.png]]
	     例如 3 ：**0110**
				0不变 ， 01得1 11得0 10得1
				结果为**0101**
				 